import "banks";
import "vars";


in rom @ 0x0000 {
  Reset: 
// Execution begins here on power-up and reset.
  nop();
  nop();
  nop();
  ^goto init;
  nop();
  nop();
/*
0000: 00              NOP                         ; This provides a slot ...
0001: 00              NOP                         ; ... to put in a JP for ...
0002: 00              NOP                         ; ... development
0003: C3 D4 18        JP      init                ; Continue startup at 18D4
0006: 00 00      ; Padding before fixed ISR address
*/
}

in rom @ 0x0008 {
  ScanLine96:
// Interrupt brings us here when the beam is *near* the middle of the screen. The real middle
// would be 224/2 = 112. The code pretends this interrupt happens at line 128.
  push(af);
  push(bc);
  push(de);
  push(hl);
  ^goto 0x08C as func;
  nop();
/*
0008: F5              PUSH    AF                  ; Save ...
0009: C5              PUSH    BC                  ; ...
000A: D5              PUSH    DE                  ; ...
000B: E5              PUSH    HL                  ; ... everything
000C: C3 8C 00        JP      $008C               ; Continue ISR at 8C
000F: 00         ; Padding before fixed ISR address
*/
}

in rom @ 0x0010 {
  ScanLine224:
// Interrupt brings us here when the beam is at the end of the screen (line 224) when the VBLANK begins.
  push(af);
  push(bc);
  push(de);
  push(hl);
  a = 0x80;
  vblankStatus = a;
  hl = &isrDelay as u16;
  --*(hl as *u8);
  CheckHandleTilt();
  a = io_read(io.INP1);
  // RRCA is no go in wiz so fake it.
  const rrca10 : u8 = 0x0F;

  ^goto registercredit if carry;
  a = (coinSwitch);
  a = a & a;
  ^goto noCoin if zero;
/*
0010: F5              PUSH    AF                  ; Save ...
0011: C5              PUSH    BC                  ; ...
0012: D5              PUSH    DE                  ; ...
0013: E5              PUSH    HL                  ; ... everything
0014: 3E 80           LD      A,$80               ; Flag that tells objects ...
0016: 32 72 20        LD      (vblankStatus),A    ; ... on the lower half of the screen to draw/move
0019: 21 C0 20        LD      HL,isrDelay         ; Decrement ...
001C: 35              DEC     (HL)                ; ... the general countdown (used for pauses)
001D: CD CD 17        CALL    CheckHandleTilt     ; Check and handle TILT
0020: DB 01           IN      A,(INP1)            ; Read coin switch
0022: 0F              RRCA                        ; Has a coin been deposited (bit 0)?
0023: DA 67 00        JP      C,$0067             ; Yes ... note that switch is closed and continue at 3F with A=1
0026: 3A EA 20        LD      A,(coinSwitch)      ; Switch is now open. Was it ...
0029: A7              AND     A                   ; ... closed last time?
002A: CA 42 00        JP      Z,$0042             ; No ... skip registering the credit
*/
}

in rom @ 0x002D {
// Handle bumping credit count
  a = numCoins;
  cmp (a,0x99);
  ^if !zero {
    a = a + (io.INP1);
    decimal_adjust();
    (numCoins) = a;
    DrawNumCredits();
  }
  a = a ^ a;
  coinSwitch = a;
/*
002D: 3A EB 20        LD      A,(numCoins)        ; Number of credits in BCD
0030: FE 99           CP      $99                 ; 99 credits already?
0032: CA 3E 00        JP      Z,$003E             ; Yes ... ignore this (better than rolling over to 00)
0035: C6 01           ADD     A,$01               ; Bump number of credits
0037: 27              DAA                         ; Make it binary coded decimal
0038: 32 EB 20        LD      (numCoins),A        ; New number of credits
003B: CD 47 19        CALL    DrawNumCredits      ; Draw credits on screen
003E: AF              XOR     A                   ; Credit switch ...
003F: 32 EA 20        LD      (coinSwitch),A      ; ... has opened
*/
  noCoin:
  a = suspendPlay;
  a = a & a;
  ^goto (0x82 as func) if zero;
  a = (gameMode); 
  a = a & a;
  ^goto (0x6f as func) if !zero;
  a = (numCoins);
  a = a & a;
  ^goto (0x5D as func) if !zero;
  ISRSplTasks();
  ^goto (0x82 as func);
/*
0042: 3A E9 20        LD      A,(suspendPlay)     ; Are we moving ...
0045: A7              AND     A                   ; ... game objects?
0046: CA 82 00        JP      Z,$0082             ; No ... restore registers and out
0049: 3A EF 20        LD      A,(gameMode)        ; Are we in ...
004C: A7              AND     A                   ; ... game mode?
004D: C2 6F 00        JP      NZ,$006F            ; Yes ... go process game-play things and out
0050: 3A EB 20        LD      A,(numCoins)        ; Number of credits
0053: A7              AND     A                   ; Are there any credits (player standing there)?
0054: C2 5D 00        JP      NZ,$005D            ; Yes ... skip any ISR animations for the splash screens
0057: CD BF 0A        CALL    ISRSplTasks         ; Process ISR tasks for splash screens
005A: C3 82 00        JP      $0082               ; Restore registers and out
*/  
}

in rom @ 0x5D {
// At this point no game is going and there are credits
  a = waitStartLoop;
  a = a & a;
  ^goto (0x82 as func) if !zero;
  ^goto WaitForStart;
/*
005D: 3A 93 20        LD      A,(waitStartLoop)   ; Are we in the ...
0060: A7              AND     A                   ; ... "press start" loop?
0061: C2 82 00        JP      NZ,$0082            ; Yes ... restore registers and out
0064: C3 65 07        JP      WaitForStart        ; Start the "press start" loop
*/
}


in rom @ 0x67 {
// Mark credit as needing registering
  registercredit:
  a = 0x01;
  coinSwitch = a;
  ^goto 0x3F as func;
/*
0067: 3E 01           LD      A,$01               ; Remember switch ...
0069: 32 EA 20        LD      (coinSwitch),A      ; ... state for debounce
006C: C3 3F 00        JP      $003F               ; Continue
*/
}

in rom @ 0x6F {
// Main game-play timing loop
  TimeFleetSound();
  a = obj2TimerExtra;
  shotSync = a;
  DrawAlien();
  RunGameObjs();
  TimeToSaucer();
  nop();
/*
006F: CD 40 17        CALL    TimeFleetSound      ; Time down fleet sound and sets flag if needs new delay value
0072: 3A 32 20        LD      A,(obj2TimerExtra)  ; Use rolling shot's timer to sync ...
0075: 32 80 20        LD      (shotSync),A        ; ... other two shots
0078: CD 00 01        CALL    DrawAlien           ; Draw the current alien (or exploding alien)
007B: CD 48 02        CALL    RunGameObjs         ; Process game objects (including player object)
007E: CD 13 09        CALL    TimeToSaucer        ; Count down time to saucer
0081: 00              NOP                         ; ** Why are we waiting?
*/

}

in rom @ 0x0082 {
  l_0x82:
  hl = pop();
  de = pop();
  bc = pop();
  af = pop();
  interrupt = true;
  return;
/*
0082: E1              POP     HL                  ; Restore ...
0083: D1              POP     DE                  ; ...
0084: C1              POP     BC                  ; ...
0085: F1              POP     AF                  ; ... everything
0086: FB              EI                          ; Enable interrupts
0087: C9              RET                         ; Return from interrupt
*/
}


in rom @ 0x88 {
  nop();
  nop();
  nop();
  nop();
/*
0088: 00 00 00 00 ; ** Why waste the space?
*/
}

in rom @ 0x8C {
// Continues here at scanline 96
  a = a ^ a;
  vblankStatus = a;
  a = suspendPlay;
  a = a & a;
  ^goto l_0x82 if zero;
  a = gameMode;
  a = a & a;
  ^goto (0xA5 as func) if !zero;
  a = isrSplashTask;
  const rrca8C : u8 = 0x0F;
  ^goto l_0x82 if !carry;
  hl = 0x2020;
  f_024b();
  CursorNextAlien();
  ^goto l_0x82;
/*
008C: AF              XOR     A                   ; Flag that tells ...
008D: 32 72 20        LD      (vblankStatus),A    ; ... objects on the upper half of screen to draw/move
0090: 3A E9 20        LD      A,(suspendPlay)     ; Are we moving ...
0093: A7              AND     A                   ; ... game objects?
0094: CA 82 00        JP      Z,$0082             ; No ... restore and return
0097: 3A EF 20        LD      A,(gameMode)        ; Are we in ...
009A: A7              AND     A                   ; ... game mode?
009B: C2 A5 00        JP      NZ,$00A5            ; Yes .... process game objects and out
009E: 3A C1 20        LD      A,(isrSplashTask)   ; Splash-animation tasks
00A1: 0F              RRCA                        ; If we are in demo-mode then we'll process the tasks anyway
00A2: D2 82 00        JP      NC,$0082            ; Not in demo mode ... done
;
00A5: 21 20 20        LD      HL,$2020            ; Game object table (skip player-object at 2010)
00A8: CD 4B 02        CALL    $024B               ; Process all game objects (except player object)
00AB: CD 41 01        CALL    CursorNextAlien     ; Advance cursor to next alien (move the alien if it is last one)
00AE: C3 82 00        JP      $0082               ; Restore and return
*/
}

/*************
 * The Aliens
 *************/

in rom @ 0xB1 {
// Initialize the player's rack of aliens. Copy the reference-location and deltas from the
// player's data bank.
  func InitRack() {
    GetAlRefPtr();
    push(hl);
    a = *(hl as *u8);
    hl++;
    h = *(hl as *u8);
    l = a;
    refAlienCr = hl;
    alienPosLSB = hl;
    hl = pop();
    hl--;
    a = *(hl as *u8);
    cmp(a,0x03);
    ^if(zero) {
      a--;
    }
    refAlienDXr = a;
    cmp(a,0xfe);
    a = 0;

    ^if zero {
      a++;
    }
    rackDirection = a;
/*
00B1: CD 86 08        CALL    GetAlRefPtr         ; 2xFC Get current player's ref-alien position pointer
00B4: E5              PUSH    HL                  ; Hold pointer
00B5: 7E              LD      A,(HL)              ; Get player's ...
00B6: 23              INC     HL                  ; ... ref-alien ...
00B7: 66              LD      H,(HL)              ; ...
00B8: 6F              LD      L,A                 ; ... coordinates
00B9: 22 09 20        LD      (refAlienYr),HL     ; Set game's reference alien's X,Y
00BC: 22 0B 20        LD      (alienPosLSB),HL    ; Set game's alien cursor bit position
00BF: E1              POP     HL                  ; Restore pointer
00C0: 2B              DEC     HL                  ; 21FB or 22FB ref alien's delta (left or right)
00C1: 7E              LD      A,(HL)              ; Get ref alien's delta X
00C2: FE 03           CP      $03                 ; If there is one alien it will move right at 3
00C4: C2 C8 00        JP      NZ,$00C8            ; Not 3 ... keep it
00C7: 3D              DEC     A                   ; If it is 3, back it down to 2 until it switches again
00C8: 32 08 20        LD      (refAlienDXr),A     ; Store alien deltaY
00CB: FE FE           CP      $FE                 ; Moving left?
00CD: 3E 00           LD      A,$00               ; Value of 0 for rack-moving-right (not XOR so flags are unaffected)
00CF: C2 D3 00        JP      NZ,$00D3            ; Not FE ... keep the value 0 for right
00D2: 3C              INC     A                   ; It IS FE ... use 1 for left
00D3: 32 0D 20        LD      (rackDirection),A   ; Store rack direction
00D6: C9              RET                         ; Done
*/
  }
}

in rom @ 0x00D7 {
  a = 2;
  p1.RefAlienDX = a;
  p2.RefAlienDX = a;
  ^goto 0x8e4 as func;
/*
00D7: 3E 02           LD      A,$02               ; Set ...
00D9: 32 FB 21        LD      (p1RefAlienDX),A    ; ... player 1 and 2 ...
00DC: 32 FB 22        LD      (p2RefAlienDX),A    ; ... alien delta to 2 (right 2 pixels)
00DF: C3 E4 08        JP      $08E4               ; 
*/
}

in rom @ 0x00E2 {
  // More empties
  const data_e2 : [u8;30] = [
    0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,
    0,0,0,0,0,0
  ];
/*
00E2: 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00F0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*/
}

/*
 This is heavily patched from a previous version of the code. There was a test here to jump to a
 self-test routine on startup (based on a dip switch). Even the original code padded with zeros
 to make the next function begin at 0100. Room for expansion?
*/

in rom @ 0x100 {
/*
  2006 holds the index into the alien flag data grid. 2067 holds the MSB of the pointer (21xx or 22xx).
  If there is an alien exploding time it down. Otherwise draw the alien if it alive (or skip if
  it isn't). If an alien is drawn (or blank) then the 2000 alien-drawing flag is cleared.
*/
  DrawAlien:
  hl = 0x2002;
  a = *(hl as *u8);
  a = a & a;
  ^goto AExplodeTime if !zero;
/*
0100: 21 02 20        LD      HL,$2002            ; Is there an ...
0103: 7E              LD      A,(HL)              ; ... alien ...
0104: A7              AND     A                   ; ... exploding?
0105: C2 38 15        JP      NZ,AExplodeTime     ; Yes ... go time it down and out
*/
}

in rom @ 0x108 {
  push(hl);
  a = alienCurIndex;
  l = a;
  a = playerDataMSB;
  h = a;
  a = *(hl as *u8);
  a = a & a;
  hl = pop();
  ^goto (0x136  as func) if zero;
  hl++;
  hl++;
  a = *(hl as *u8);
  hl++;
  b = *(hl as *u8);
  a = a & 0xFE;
  const rlca : [u8] = [0x07,0x07,0x07];
  //  a = a <<<<3;
  e = a;
  d = 0;
  hl = 0x1c00;
  hl = hl + de;
  swap(de,hl);
  a = b;
  a = a & a;
  const ifz : [u8] = [0xC4, 0x3B, 0x01]; // 012B: C4 3B 01        CALL    NZ,$013B            ; No ... add 30 and use position 1 alien sprites
  hl = alienPosLSB;
  b = 0x10;
  DrawSprite();
  /*
  0108: E5              PUSH    HL                  ; 2002 on the stack
0109: 3A 06 20        LD      A,(alienCurIndex)   ; Get alien index ...
010C: 6F              LD      L,A                 ; ... for the 21xx or 22xx pointer
010D: 3A 67 20        LD      A,(playerDataMSB)   ; Get MSB ...
0110: 67              LD      H,A                 ; ... of data area (21xx or 22xx)
0111: 7E              LD      A,(HL)              ; Get alien status flag
0112: A7              AND     A                   ; Is the alien alive?
0113: E1              POP     HL                  ; HL=2002
0114: CA 36 01        JP      Z,$0136             ; No alien ... skip drawing alien sprite (but flag done)
0117: 23              INC     HL                  ; HL=2003 Bump descriptor
0118: 23              INC     HL                  ; HL=2004 Point to alien's row
0119: 7E              LD      A,(HL)              ; Get alien type
011A: 23              INC     HL                  ; HL=2005 Bump descriptor
011B: 46              LD      B,(HL)              ; Get animation number
011C: E6 FE           AND     $FE                 ; Translate row to type offset as follows: ...
011E: 07              RLCA                        ; ... 0,1 -> 32 (type 1) ...
011F: 07              RLCA                        ; ... 2,3 -> 16 (type 2) ...
0120: 07              RLCA                        ; ...   4 -> 32 (type 3) on top row
0121: 5F              LD      E,A                 ; Sprite offset LSB
0122: 16 00           LD      D,$00               ; MSB is 0
0124: 21 00 1C        LD      HL,$1C00            ; Position 0 alien sprites
0127: 19              ADD     HL,DE               ; Offset to sprite type
0128: EB              EX      DE,HL               ; Sprite offset to DE
0129: 78              LD      A,B                 ; Animation frame number
012A: A7              AND     A                   ; Is it position 0?
012B: C4 3B 01        CALL    NZ,$013B            ; No ... add 30 and use position 1 alien sprites
012E: 2A 0B 20        LD      HL,(alienPosLSB)    ; Pixel position
0131: 06 10           LD      B,$10               ; 16 rows in alien sprites
0133: CD D3 15        CALL    DrawSprite          ; Draw shifted sprite
*/
}

in rom @ 0x136 {
  a = a ^ a;
  waitOnDraw = a;
  return;
}

in rom @ 0x13b {
  func f_013b() {
    hl = 0x30;
    hl +=de;
    swap(de,hl);
/*
0136: AF              XOR     A                   ; Let the ISR routine ...
0137: 32 00 20        LD      (waitOnDraw),A      ; ... advance the cursor to the next alien
013A: C9              RET                         ; Out
*/
  }
}

in rom @ 0x0141 {
  CursorNextAlien:
/*
  This is called from the mid-screen ISR to set the cursor for the next alien to draw.
  When the cursor moves over all aliens then it is reset to the beginning and the reference
  alien is moved to its next position.
 
  The flag at 2000 keeps this in sync with the alien-draw routine called from the end-screen ISR.
  When the cursor is moved here then the flag at 2000 is set to 1. This routine will not change
  the cursor until the alien-draw routine at 100 clears the flag. Thus no alien is skipped.
*/
  a = playerOK;
  a = a & a;
  return if zero;
  a = waitOnDraw;
  a = a & a;
  return if !zero;
  a = playerDataMSB;
  h = a;
  a = alienCurIndex;
  d = 2;
  a++;
  cmp(a,0x37);
  const ifz141 : [u8] = [0xcc,0xa1, 0x01]; // CC A1 01 CALL Z,MoveRefAlien 

  l = a;
  b = *(hl as *u8);
  b--;
  ^goto (0x154 as func) if !zero; 
  alienCurIndex = a;
  GetAlienCoords();
  h=c;
  alienPosLSB = hl;
  a=l;
  cmp(a,0x28);
  ^goto (0x1971 as func) if carry;
  a=d;
  alienRow = a;
  a=1;
  waitOnDraw = a;
  return;
/*
0141: 3A 68 20        LD      A,(playerOK)        ; Is the player ...
0144: A7              AND     A                   ; ... blowing up?
0145: C8              RET     Z                   ; Yes ... ignore the aliens
0146: 3A 00 20        LD      A,(waitOnDraw)      ; Still waiting on ...
0149: A7              AND     A                   ; ... this alien to be drawn?
014A: C0              RET     NZ                  ; Yes ... leave cursor in place
014B: 3A 67 20        LD      A,(playerDataMSB)   ; Load alien-data ...
014E: 67              LD      H,A                 ; ... MSB (either 21xx or 22xx)
014F: 3A 06 20        LD      A,(alienCurIndex)   ; Load the xx part of the alien flag pointer
0152: 16 02           LD      D,$02               ; When all are gone this triggers 1A1 to return from this stack frame
0154: 3C              INC     A                   ; Have we drawn all aliens ...
0155: FE 37           CP      $37                 ; ... at last position?
0157: CC A1 01        CALL    Z,MoveRefAlien      ; Yes ... move the bottom/right alien and reset index to 0
015A: 6F              LD      L,A                 ; HL now points to alien flag
015B: 46              LD      B,(HL)              ; Is alien ...
015C: 05              DEC     B                   ; ... alive?
015D: C2 54 01        JP      NZ,$0154            ; No ... skip to next alien
0160: 32 06 20        LD      (alienCurIndex),A   ; New alien index
0163: CD 7A 01        CALL    GetAlienCoords      ; Calculate bit position and type for index
0166: 61              LD      H,C                 ; The calculation returns the MSB in C
0167: 22 0B 20        LD      (alienPosLSB),HL    ; Store new bit position
016A: 7D              LD      A,L                 ; Has this alien ...
016B: FE 28           CP      $28                 ; ... reached the end of screen?
016D: DA 71 19        JP      C,$1971             ; Yes ... kill the player
0170: 7A              LD      A,D                 ; This alien's ...
0171: 32 04 20        LD      (alienRow),A        ; ... row index
0174: 3E 01           LD      A,$01               ; Set the wait-flag for the ...
0176: 32 00 20        LD      (waitOnDraw),A      ; ... draw-alien routine to clear
0179: C9              RET                         ; Done
*/
}

in rom @ 0x17A {
  GetAlienCoords:
/*
  Convert alien index in L to screen bit position in C,L.
  Return alien row index (converts to type) in D.
*/
  d = 0;
  a = l;
  hl = 0x2009;
  b = *(hl as *u8);
  hl++;
  c = *(hl as *u8);
  ^while (true) {
    cmp(a,0xb);
    goto 0x194 as func if negative;
    a = a -#0x0b;
      e = a;
    a = b;
    a = a + 0x10;
    b = a;
    a = e;
    d++;
  }
/*
017A: 16 00           LD      D,$00               ; Row 0
017C: 7D              LD      A,L                 ; Hold onto alien index
017D: 21 09 20        LD      HL,$2009            ; Get alien X ...
0180: 46              LD      B,(HL)              ; ... to B
0181: 23              INC     HL                  ; Get alien y ...
0182: 4E              LD      C,(HL)              ; ... to C
0183: FE 0B           CP      $0B                 ; Can we take a full row off of index?
0185: FA 94 01        JP      M,$0194             ; No ... we have the row
0188: DE 0B           SBC     A,$0B               ; Subtract off 11 (one whole row)
018A: 5F              LD      E,A                 ; Hold the new index
018B: 78              LD      A,B                 ; Add ...
018C: C6 10           ADD     A,$10               ; ... 16 to bit ...
018E: 47              LD      B,A                 ; ... position Y (1 row in rack)
018F: 7B              LD      A,E                 ; Restore tallied index
0190: 14              INC     D                   ; Next row
0191: C3 83 01        JP      $0183               ; Keep skipping whole rows
*/
}

in rom @ 0x194 {
  l = b;
  ^while(true) {
    a = a & a;
    return if zero;
    e = a;
    a = c;
    a = a + 0x10;
    c = a;
    a = e;
    a--;
  }
/*
0194: 68              LD      L,B                 ; We have the LSB (the row)
0195: A7              AND     A                   ; Are we in the right column?
0196: C8              RET     Z                   ; Yes ... X and Y are right
0197: 5F              LD      E,A                 ; Hold index
0198: 79              LD      A,C                 ; Add ...
0199: C6 10           ADD     A,$10               ; ... 16 to bit ...
019B: 4F              LD      C,A                 ; ... position X (1 column in rack)
019C: 7B              LD      A,E                 ; Restore index
019D: 3D              DEC     A                   ; We adjusted for 1 column
019E: C3 95 01        JP      $0195               ; Keep moving over column
*/
}

in rom @ 0x1A1 {
  func MoveRefAlien() {
    d--;
    ^goto ReturnTwo if zero;
    hl = 0x2006;
    *(hl as *u8) = 0;
    hl++;
    c = *(hl as *u8);
    *(hl as *u8) = 0;
    AddDelta();
    hl = 0x2005;
    a = *(hl as *u8);
    a++;
    a = a & 0x01;
    *(hl as *u8) = a;
    a = a ^ a;
    hl = 0x2067;
    h = *(hl as *u8);

/*; The "reference alien" is the bottom left. All other aliens are drawn relative to this
; reference. This routine moves the reference alien (the delta is set elsewhere) and toggles
; the animation frame number between 0 and 1.
;
01A1: 15              DEC     D                   ; This decrements with each call to move
01A2: CA CD 01        JP      Z,ReturnTwo         ; Return out of TWO call frames (only used if no aliens left)
01A5: 21 06 20        LD      HL,$2006            ; Set current alien ...
01A8: 36 00           LD      (HL),$00            ; ... index to 0
01AA: 23              INC     HL                  ; Point to DeltaX
01AB: 4E              LD      C,(HL)              ; Load DX into C
01AC: 36 00           LD      (HL),$00            ; Set DX to 0
01AE: CD D9 01        CALL    AddDelta            ; Move alien
01B1: 21 05 20        LD      HL,$2005            ; Alien animation frame number
01B4: 7E              LD      A,(HL)              ; Toggle ...
01B5: 3C              INC     A                   ; ... animation ...
01B6: E6 01           AND     $01                 ; ... number between ...
01B8: 77              LD      (HL),A              ; ... 0 and 1
01B9: AF              XOR     A                   ; Alien index in A is now 0
01BA: 21 67 20        LD      HL,$2067            ; Restore H ...
01BD: 66              LD      H,(HL)              ; ... to player data MSB (21 or 22)
01BE: C9              RET                         ; Done
*/
  }
  nop();
/*
01BF: 00 ; ** Why?
*/
}

in rom @ 0x1C0 {
// Initialize the 55 aliens from last to 1st. 1 means alive.
  func InitAliens() {
    hl = 0x2100;
    b = 0x37;
    ^do {
    *(hl as *u8) = 1;
    hl++;
    b--;
    } while !zero;
/*
01C0: 21 00 21        LD      HL,$2100            ; Start of alien structures (this is the last alien)
01C3: 06 37           LD      B,$37               ; Count to 55 (that's five rows of 11 aliens)
01C5: 36 01           LD      (HL),$01            ; Bring alien to live
01C7: 23              INC     HL                  ; Next alien
01C8: 05              DEC     B                   ; All done?
01C9: C2 C5 01        JP      NZ,$01C5            ; No ... keep looping
01CC: C9              RET                         ; Done
*/
}

in rom @ 0x1CD {
  func ReturnTwo() {
/*
  If there are no aliens left on the screen then MoveDrawAlien comes here which returns from the
  caller's stack frame.
*/
    hl = pop();
/*
01CD: E1              POP     HL                  ; Drop return to caller
01CE: C9              RET                         ; Return to caller's caller
*/
  }
}
  
  
/********
 * Misc
 ********/

in rom @ 0x1CF {
/*
  Draw a 1px line across the player's stash at the bottom of the screen.
*/
  #[fallthrough] func DrawBottomLine() {
    a = 1;
    b = 0xe0;
    hl = 0x2402;
    ^goto 0x14CC as func;
/*
01CF: 3E 01           LD      A,$01               ; Bit 1 set ... going to draw a 1-pixel stripe down left side
01D1: 06 E0           LD      B,$E0               ; All the way down the screen
01D3: 21 02 24        LD      HL,$2402            ; Screen coordinates (3rd byte from upper left)
01D6: C3 CC 14        JP      $14CC               ; Draw line down left side
*/
  }
}
in rom @ 0x1D9 {
/*
  HL points to descriptor: DX DY XX YY except DX is already loaded in C
  ** Why the "already loaded" part? Why not just load it here?
*/
 func AddDelta() {
   hl++;
   b = *(hl as *u8);
   hl++;
   a = c;
   a = a + *(hl as *u8);
   *(hl as *u8) = a;
   hl++;
   a = b;
   a = a + *(hl as *u8);
   *(hl as *u8) = a;
/*
01D9: 23              INC     HL                  ; We loaded delta-x already ... skip over it
01DA: 46              LD      B,(HL)              ; Get delta-y
01DB: 23              INC     HL                  ; Skip over it
01DC: 79              LD      A,C                 ; Add delta-x ...
01DD: 86              ADD     A,(HL)              ; ... to x
01DE: 77              LD      (HL),A              ; Store new x
01DF: 23              INC     HL                  ; Skip to y
01E0: 78              LD      A,B                 ; Add delta-y ...
01E1: 86              ADD     A,(HL)              ; ... to y
01E2: 77              LD      (HL),A              ; Store new y
01E3: C9              RET                         ; Done
*/
}

in rom @ 0x1E4 {
/*
  Block copy ROM mirror 1B00-1BBF to initialize RAM at 2000-20BF.
*/
  #[fallthrough] func CopyRAMMirror() {
    b = 0xC0;
/*
01E4: 06 C0           LD      B,$C0               ; Number of bytes
*/
  }
  de = 0x1B00;
  hl = 0x2000;
  ^goto BlockCopy;
/*
01E6: 11 00 1B        LD      DE,$1B00            ; RAM mirror in ROM
01E9: 21 00 20        LD      HL,$2000            ; Start of RAM
01EC: C3 32 1A        JP      BlockCopy           ; Copy [DE]->[HL] and return
*/
}
  
/************************
 * Copy/Restore Shields *
 ************************/

in rom @ 0x1EF {
/*
  Draw the shields for player 1 (draws it in the buffer in the player's data area).
*/
  #[fallthrough] func DrawShieldPl1() {
    hl = 0x2142;
    ^goto DrawShield;
/*
01EF: 21 42 21        LD      HL,$2142            ; Player 1 shield buffer (remember between games in multi-player)
01F2: C3 F8 01        JP      $01F8               ; Common draw point
*/
  }
/*
; Draw the shields for player 2 (draws it in the buffer in the player's data area).
*/
  #[fallthrough] func DrawShieldPl2() {
    hl = 0x2242;
/*
01F5: 21 42 22        LD      HL,$2242            ; Player 2 shield buffer (remember between games in multi-player)
*/
  }
  DrawShield:
  c = 4;
  de = 0x1d20;
  ^do {
  push(de);
  b = 0x2c;
  BlockCopy();
  de = pop();
  c--;
  } while !zero;
  return;
/*
01F8: 0E 04           LD      C,$04               ; Going to draw 4 shields
01FA: 11 20 1D        LD      DE,$1D20            ; Shield pixel pattern
01FD: D5              PUSH    DE                  ; Hold the start for the next shield
01FE: 06 2C           LD      B,$2C               ; 44 bytes to copy
0200: CD 32 1A        CALL    BlockCopy           ; Block copy DE to HL (B bytes)
0203: D1              POP     DE                  ; Restore start of shield pattern
0204: 0D              DEC     C                   ; Drawn all shields?
0205: C2 FD 01        JP      NZ,$01FD            ; No ... go draw them all
0208: C9              RET             
*/
}
  
in rom @ 0x209 {
/*
; Copy shields on the screen to player 1's data area.
*/
  #[fallthrough] func RememberShields1() {
    a = 1;
    ^goto 0x21b as func;
/*
0209: 3E 01           LD      A,$01               ; Not zero means remember
020B: C3 1B 02        JP      $021B               ; Shuffle-shields player 1
*/
  }

/*
; Copy shields on the screen to player 2's data area.
*/
  #[fallthrough] func RememberShields2() {
    a = 1;
    ^goto 0x214 as func;
/*
020E: 3E 01           LD      A,$01               ; Not zero means remember
0210: C3 14 02        JP      $0214               ; Shuffle-shields player 2
*/
  }
/*
; Copy shields from player 2's data area to screen.
*/
  #[fallthrough] func RestoreShields2() {
    a = a ^ a;
    de = 0x2242;
    ^goto CopyShields;
  }
/*
0213: AF              XOR     A                   ; Zero means restore
0214: 11 42 22        LD      DE,$2242            ; Player 2 shield buffer (remember between games in multi-player)
0217: C3 1E 02        JP      CopyShields         ; Shuffle-shields player 2
*/

/*
; Copy shields from player 1's data area to screen.
*/
    #[fallthrough] func RestoreShields1() {
      a = a ^ a;
      de = 0x2142;
    }
/*
021A: AF              XOR     A                   ; Zero means restore
021B: 11 42 21        LD      DE,$2142            ; Player 1 shield buffer (remember between games in multi-player)
*/

/*      
; A is 1 for screen-to-buffer, 0 for to buffer-to-screen
; HL is screen coordinates of first shield. There are 23 rows between shields.
; DE is sprite buffer in memory.
*/
CopyShields:
  tmp2081 = a;
  bc = 0x1602;
  hl = 0x2806;
  a = 4;
  push(af);
  push(bc);
  a = tmp2081;
  a = a & a;
  ^goto 0x242 as func if !zero;
  RestoreShields();
  bc = pop();
  af = pop();
  a--;
  return if zero;
  push(de);
  de = 0x2e0;
  hl = hl + de;
  de = pop();
  ^goto 0x229 as func;
/*
021E: 32 81 20        LD      (tmp2081),A         ; Remember copy/restore flag
0221: 01 02 16        LD      BC,$1602            ; 22 rows, 2 bytes/row (for 1 shield pattern)
0224: 21 06 28        LD      HL,$2806            ; Screen coordinates
0227: 3E 04           LD      A,$04               ; Four shields to move
0229: F5              PUSH    AF                  ; Hold shield count
022A: C5              PUSH    BC                  ; Hold sprite-size
022B: 3A 81 20        LD      A,(tmp2081)         ; Get back copy/restore flag
022E: A7              AND     A                   ; Not zero ...
022F: C2 42 02        JP      NZ,$0242            ; ... means remember shidles
0232: CD 69 1A        CALL    RestoreShields      ; Restore player's shields
0235: C1              POP     BC                  ; Get back sprite-size
0236: F1              POP     AF                  ; Get back shield count
0237: 3D              DEC     A                   ; Have we moved all shields?
0238: C8              RET     Z                   ; Yes ... out
0239: D5              PUSH    DE                  ; Hold sprite buffer
023A: 11 E0 02        LD      DE,$02E0            ; Add 2E0 (23 rows) to get to ...
023D: 19              ADD     HL,DE               ; ... next shield on screen
023E: D1              POP     DE                  ; restore sprite buffer
023F: C3 29 02        JP      $0229               ; Go back and do all
*/
  RememberShields();
  ^goto 0x235 as func;
/*
0242: CD 7C 14        CALL    RememberShields     ; Remember player's shields
0245: C3 35 02        JP      $0235               ; Continue with next shield
*/
}

  
// Game Objects *
  
in rom @ 0x248 {
/*
; Process game objects. Each game object has a 16 byte structure. The handler routine for the object
; is at xx03 and xx04 of the structure. The pointer to xx04 is pushed onto the stack before calling
; the handler.
;
; All game objects (except task 0 ... the player) are called at the mid-screen and end-screen renderings.
; Each object decides when to run based on its Y (not rotated) coordinate. If an object is on the lower
; half of the screen then it does its work when the beam is at the top of the screen. If an object is
; on the top of the screen then it does its work when the beam is at the bottom. This keeps the
; object from updating while it is being drawn which would result in an ugly flicker.
;
;
; The player is only processed at the mid-screen interrupt. I am not sure why.
;
; The first three bytes of the structure are used for status and timers.
;
; If the first byte is FF then the end of the game-task list has been reached.
; If the first byte is FE then the object is skipped.
;
; If the first-two bytes are non-zero then they are treated like a two-byte counter
; and decremented as such. The 2nd byte is the LSB (moves the fastest).
;
; If the first-two bytes are zero then the third byte is treated as an additional counter. It
; is decremented as such.
;
; When all three bytes reach zero the task is executed.
;
; The third-byte-counter was used as a speed-governor for the player's object, but evidently even the slowest
; setting was too slow. It got changed to 0 (fastest possible).
*/
RunGameObjs:
  hl = 0x2010;
  f_024b:

  a = *(hl as *u8);
  cmp(a,0xff);
  return if zero;
  cmp(a,0xfe);
  ^goto 0x281 as func if zero;
  hl++;
  b = *(hl as *u8);
  c = a;
  a = a | b;
  a = c;
  ^goto 0x277 as func if !zero;  
/*
0248: 21 10 20        LD      HL,$2010            ; First game object (active player)
024B: 7E              LD      A,(HL)              ; Have we reached the ...
024C: FE FF           CP      $FF                 ; ... end of the object list?
024E: C8              RET     Z                   ; Yes ... done
024F: FE FE           CP      $FE                 ; Is object active?
0251: CA 81 02        JP      Z,$0281             ; No ... skip it
0254: 23              INC     HL                  ; xx01
0255: 46              LD      B,(HL)              ; First byte to B
0256: 4F              LD      C,A                 ; Hold 1st byte
0257: B0              OR      B                   ; OR 1st and 2nd byte
0258: 79              LD      A,C                 ; Restore 1st byte
0259: C2 77 02        JP      NZ,$0277            ; If word at xx00,xx02 is non zero then decrement it
*/
  hl++;
  a = *(hl as *u8);
  a = a & a;
  ^goto 0x288 as func if !zero;
  hl++;
  e = *(hl as *u8);
  hl++;
  d = *(hl as *u8);
  push(hl);
  swap(de,hl);
  push(hl);
  hl = 0x026F;
  const d026c : u8 = 0xe3;//  swap(sp,hl);
  push(de);
  ^goto (hl as func);
  hl = pop();
  de = 0xc;
  hl+=de;
  ^goto 0x24b as func;
  /*
025C: 23              INC     HL                  ; xx02
025D: 7E              LD      A,(HL)              ; Get byte counter
025E: A7              AND     A                   ; Is it 0?
025F: C2 88 02        JP      NZ,$0288            ; No ... decrement byte counter at xx02
0262: 23              INC     HL                  ; xx03
0263: 5E              LD      E,(HL)              ; Get handler address LSB
0264: 23              INC     HL                  ; xx04
0265: 56              LD      D,(HL)              ; Get handler address MSB
0266: E5              PUSH    HL                  ; Remember pointer to MSB
0267: EB              EX      DE,HL               ; Handler address to HL
0268: E5              PUSH    HL                  ; Now to stack (making room for indirect call)
0269: 21 6F 02        LD      HL,$026F            ; Return address to 026F
026C: E3              EX      (SP),HL             ; Return address (026F) now on stack. Handler in HL.
026D: D5              PUSH    DE                  ; Push pointer to data struct (xx04) for handler to use
026E: E9              JP      (HL)                ; Run object's code (will return to next line)
026F: E1              POP     HL                  ; Restore pointer to xx04
0270: 11 0C 00        LD      DE,$000C            ; Offset to next ...
0273: 19              ADD     HL,DE               ; ... game task (C+4=10)
0274: C3 4B 02        JP      $024B               ; Do next game task
*/
}

in rom @ 0x277 {
// Word at xx00 and xx01 is non-zero. Decrement it and move to next task.
  b--;
  b++;
  ^goto 0x27d as func if !zero;
  a--;
  b--;
  *(hl as *u8) = b;
  hl--;
  *(hl as *u8) = a;
  
/*
0277: 05              DEC     B                   ; Decrement ...
0278: 04              INC     B                   ; ... two ...
0279: C2 7D 02        JP      NZ,$027D            ; ... byte ...
027C: 3D              DEC     A                   ; ... value ...
027D: 05              DEC     B                   ; ... at ...
027E: 70              LD      (HL),B              ; ... xx00 ...
027F: 2B              DEC     HL                  ; ... and ...
0280: 77              LD      (HL),A              ; ... xx01
*/

  de = 0x10;
  hl+=de;
  ^goto 0x24b as func;  
/*
0281: 11 10 00        LD      DE,$0010            ; Next ...
0284: 19              ADD     HL,DE               ; ... object descriptor
0285: C3 4B 02        JP      $024B               ; Keep processing game objects
*/
/*
; Word at xx00 and xx01 is zero and byte at xx02 is non-zero. Decrement xx02 and
; move to next task.
*/
  --*(hl as *u8);
  hl--;
  hl--;
  ^goto 0x281 as func;
/*
0288: 35              DEC     (HL)                ; Decrement the xx02 counter
0289: 2B              DEC     HL                  ; Back up to ...
028A: 2B              DEC     HL                  ; ... start of game task
028B: C3 81 02        JP      $0281               ; Next game task
*/
}

in rom @ 0x28E {
/*
; Game object 0: Move/draw the player
;
; This task is only called at the mid-screen ISR. It ALWAYS does its work here, even though
; the player can be on the top or bottom of the screen (not rotated).
;
*/
   GameObj0:
  hl = pop();
  hl++;
  a = *(hl as *u8);
  cmp(a,0xff);
  ^goto 0x33b as func if zero;
/*
028E: E1              POP     HL                  ; Get player object structure 2014
028F: 23              INC     HL                  ; Point to blow-up status
0290: 7E              LD      A,(HL)              ; Get player blow-up status
0291: FE FF           CP      $FF                 ; Player is blowing up?
0293: CA 3B 03        JP      Z,$033B             ; No ... go do normal movement
*/

// Handle blowing up player
  hl++;
  --*(hl as *u8);
  return if !zero;
  b = a;
  a = a ^ a;
  playerOK = a;
  enableAlienFire = a;
  a = 0x30;
  alienFireDelay = a;
  a = b;
  *(hl as *u8) = 5;
  hl++;
  --*(hl as *u8);
  ^goto DrawPlayerDie if !zero;
  
/*
0296: 23              INC     HL                  ; Point to blow-up delay count
0297: 35              DEC     (HL)                ; Decrement the blow-up delay
0298: C0              RET     NZ                  ; Not time for a new blow-up sprite ... out
0299: 47              LD      B,A                 ; Hold sprite image number
029A: AF              XOR     A                   ; 0
029B: 32 68 20        LD      (playerOK),A        ; Player is NOT OK ... player is blowing up
029E: 32 69 20        LD      (enableAlienFire),A ; Alien fire is disabled
02A1: 3E 30           LD      A,$30               ; Reset count ...
02A3: 32 6A 20        LD      (alienFireDelay),A  ; ... till alien shots are enabled
02A6: 78              LD      A,B                 ; Restore sprite image number (used if we go to 39B)
02A7: 36 05           LD      (HL),$05            ; Reload time between blow-up changes
02A9: 23              INC     HL                  ; Point to number of blow-up changes
02AA: 35              DEC     (HL)                ; Count down blow-up changes
02AB: C2 9B 03        JP      NZ,DrawPlayerDie    ; Still blowing up ... go draw next sprite
*/
}
  
in rom @ 0x2AE {
 
// Blow up finished
  hl = playerYr16;
  b = 0x10;
  EraseSimpleSprite();
  hl = 0x2010;
  de = 0x1B10;
  b = 0x10;
  BlockCopy();
  b = 0;
  SoundBits3Off();
  a = invaded;
  a = a & a;
  return if !zero;
  a = gameMode;
  a = a & a;
  return if zero;
  sp = 0x2400;
  interrupt = true;
  DisableGameTasks();
  (0x92E as func)();
  a = a & a;
  ^goto (0x166d as func) if zero;
  (0x18e7 as func)();
  a = *(hl as *u8);
  a = a & a;
  ^goto (0x32c as func) if zero;
  a = twoPlayers;
  a = a & a;
  ^goto (0x32c as func) if zero;
  a = playerDataMSB;
  push(af);
  const data2f0 : u8 = 0x0f; // RRCA
  ^goto 0x332 as func if carry;
  RememberShields2();
  (0x878 as func)();
  *(hl as *u8) = e;
  hl++;
  *(hl as *u8) = d;
  hl--;
  hl--;
  *(hl as *u8) = b;
  nop();
  CopyRAMMirror();
  af = pop();
  const data306 : u8 = 0x0f; // RRCA
  a = 0x21;
  b = 0;
  ^goto 0x312 as func if !carry;
  b = 0x20;
  a = 0x22;
  playerDataMSB = a;
  TwoSecDelay();
  a = a ^ a;
  obj0TimerLSB = a;
  a = b;
  io_write(io.SOUND2,a);
  a++;
  soundPort5 = a;
  ClearPlayField();
  RemoveShip();
  ^goto 0x7F9 as func;
  /*
02AE: 2A 1A 20        LD      HL,(playerYr)       ; Player's coordinates
02B1: 06 10           LD      B,$10               ; 16 Bytes
02B3: CD 24 14        CALL    EraseSimpleSprite   ; Erase simple sprite (the player)
02B6: 21 10 20        LD      HL,$2010            ; Restore player ...
02B9: 11 10 1B        LD      DE,$1B10            ; ... structure ...
02BC: 06 10           LD      B,$10               ; ... from ...
02BE: CD 32 1A        CALL    BlockCopy           ; ... ROM mirror
02C1: 06 00           LD      B,$00               ; Turn off ...
02C3: CD DC 19        CALL    SoundBits3Off       ; ... all sounds
02C6: 3A 6D 20        LD      A,(invaded)         ; Has rack reached ...
02C9: A7              AND     A                   ; ... the bottom of the screen?
02CA: C0              RET     NZ                  ; Yes ... done here
02CB: 3A EF 20        LD      A,(gameMode)        ; Are we in ...
02CE: A7              AND     A                   ; ... game mode?
02CF: C8              RET     Z                   ; No ... return to splash screens
02D0: 31 00 24        LD      SP,$2400            ; We aren't going to return
02D3: FB              EI                          ; Enable interrupts (we just dropped the ISR context)
02D4: CD D7 19        CALL    DsableGameTasks     ; Disable game tasks
02D7: CD 2E 09        CALL    $092E               ; Get number of ships for active player
02DA: A7              AND     A                   ; Any left?
02DB: CA 6D 16        JP      Z,$166D             ; No ... handle game over for player
02DE: CD E7 18        CALL    $18E7               ; Get player-alive status pointer
02E1: 7E              LD      A,(HL)              ; Is player ...
02E2: A7              AND     A                   ; ... alive?
02E3: CA 2C 03        JP      Z,$032C             ; Yes ... remove a ship from player's stash and reenter game loop
02E6: 3A CE 20        LD      A,(twoPlayers)      ; Multi-player game
02E9: A7              AND     A                   ; Only one player?
02EA: CA 2C 03        JP      Z,$032C             ; Yes ... remove a ship from player's stash and reenter game loop
02ED: 3A 67 20        LD      A,(playerDataMSB)   ; Player data MSB
02F0: F5              PUSH    AF                  ; Hold the MSB
02F1: 0F              RRCA                        ; Player 1 is active player?
02F2: DA 32 03        JP      C,$0332             ; Yes ... go store player 1 shields and come back to 02F8
02F5: CD 0E 02        CALL    RememberShields2    ; No ... go store player 2 shields
02F8: CD 78 08        CALL    $0878               ; Get ref-alien info and pointer to storage
02FB: 73              LD      (HL),E              ; Hold the ...
02FC: 23              INC     HL                  ; ... ref-alien ...
02FD: 72              LD      (HL),D              ; ... screen coordinates
02FE: 2B              DEC     HL                  ; Back up ...
02FF: 2B              DEC     HL                  ; .. to delta storage
0300: 70              LD      (HL),B              ; Store ref-alien's delta (direction)
0301: 00              NOP                         ; ** Why?
0302: CD E4 01        CALL    CopyRAMMirror       ; Copy RAM mirror (getting ready to switch players)
0305: F1              POP     AF                  ; Restore active player MSB
0306: 0F              RRCA                        ; Player 1?
0307: 3E 21           LD      A,$21               ; Player 1 data pointer
0309: 06 00           LD      B,$00               ; Cocktail bit=0 (player 1)
030B: D2 12 03        JP      NC,$0312            ; It was player one ... keep data for player 2
030E: 06 20           LD      B,$20               ; Cocktail bit=1 (player 2)
0310: 3E 22           LD      A,$22               ; Player 2 data pointer
0312: 32 67 20        LD      (playerDataMSB),A   ; Change players
0315: CD B6 0A        CALL    TwoSecDelay         ; Two second delay
0318: AF              XOR     A                   ; Clear the player-object ...
0319: 32 11 20        LD      (obj0TimerLSB),A    ; ... timer (player can move instantly after switching players)
031C: 78              LD      A,B                 ; Cocktail bit to A
031D: D3 05           OUT     (SOUND2),A          ; Set the cocktail mode
031F: 3C              INC     A                   ; Fleet sound 1 (first tone)
0320: 32 98 20        LD      (soundPort5),A      ; Set the port 5 hold
0323: CD D6 09        CALL    ClearPlayField      ; Clear center window
0326: CD 7F 1A        CALL    RemoveShip          ; Remove a ship and update indicators
0329: C3 F9 07        JP      $07F9               ; Tell the players that the switch has been made
*/
  RemoveShip();
  ^goto (0x817 as func);
/*
032C: CD 7F 1A        CALL    RemoveShip          ; Remove a ship and update indicators
032F: C3 17 08        JP      $0817               ; Continue into game loop
*/
  RememberShields1();
  ^goto (0x2F8 as func);
/*
0332: CD 09 02        CALL    RememberShields1    ; Remember the shields for player 1
0335: C3 F8 02        JP      $02F8               ; Back to switching-players above
*/
}

in rom @ 0x338 {
  const data338 : [u8;3] = [0,0,0];
/*
0338: 00 00 00 ; ** Why
*/
}

in rom @ 0x33B {
// Player not blowing up ... handle inputs
  hl = 0x2068;
  *(hl as *u8) = 1;
  hl++;
  a = *(hl as *u8);
  a = a & a;
  ^goto 0x3b0 as func;
/*
033B: 21 68 20        LD      HL,$2068            ; Player OK flag
033E: 36 01           LD      (HL),$01            ; Flag 1 ... player is OK
0340: 23              INC     HL                  ; 2069
0341: 7E              LD      A,(HL)              ; Alien shots enabled?
0342: A7              AND     A                   ; Set flags
0343: C3 B0 03        JP      $03B0               ; Continue
*/
  nop();
  hl--;
  *(hl as *u8) = 1;
/*
0346: 00              NOP                         ; ** Why?
0347: 2B              DEC     HL                  ; 2069
0348: 36 01           LD      (HL),$01            ; Enable alien fire
*/
  a = playerXr;
  b = a;
  a = gameMode;
  a = a & a;
  ^goto (0x363 as func) if !zero;
/*
034A: 3A 1B 20        LD      A,(playerXr)        ; Current player coordinates
034D: 47              LD      B,A                 ; Hold it
034E: 3A EF 20        LD      A,(gameMode)        ; Are we in ...
0351: A7              AND     A                   ; ... game mode?
0352: C2 63 03        JP      NZ,$0363            ; Yes ... use switches as player controls
*/
  a = nextDemoCmd;
  const data0358 : u8 = 0x0f;
  ^goto MovePlayerRight if carry;
  const data035C : u8 = 0x0f;
  ^goto MovePlayerLeft if carry;
  ^goto (0x36F as func);
  
/*
0355: 3A 1D 20        LD      A,(nextDemoCmd)     ; Get demo command
0358: 0F              RRCA                        ; Is it right?
0359: DA 81 03        JP      C,MovePlayerRight   ; Yes ... do right
035C: 0F              RRCA                        ; Is it left?
035D: DA 8E 03        JP      C,MovePlayerLeft    ; Yes ... do left
0360: C3 6F 03        JP      $036F               ; Skip over movement (draw player and out)
*/
  
// Player is in control
  ReadInputs();
  const data366 : [u8] = [7,7];
  ^goto MovePlayerRight if carry;
  const data36B : u8 = 7;
  ^goto MovePlayerLeft if carry;
/*
0363: CD C0 17        CALL    ReadInputs          ; Read active player controls
0366: 07              RLCA                        ; Test for ...
0367: 07              RLCA                        ; ... right button
0368: DA 81 03        JP      C,MovePlayerRight   ; Yes ... handle move right
036B: 07              RLCA                        ; Test for left button
036C: DA 8E 03        JP      C,MovePlayerLeft    ; Yes ... handle move left
*/
  
// Draw player sprite
  hl = 0x2018;
  ReadDesc();
  ConvToScr();
  DrawSimpSprite();
  a = 0;
  obj0TimerExtra = a;
  return;
/*
036F: 21 18 20        LD      HL,$2018            ; Active player descriptor
0372: CD 3B 1A        CALL    ReadDesc            ; Load 5 byte sprite descriptor in order: EDLHB
0375: CD 47 1A        CALL    ConvToScr           ; Convert HL to screen coordinates
0378: CD 39 14        CALL    DrawSimpSprite      ; Draw player
037B: 3E 00           LD      A,$00               ; Clear the task timer. Nobody changes this but it could have ...
037D: 32 12 20        LD      (obj0TimerExtra),A  ; ... been speed set for the player with a value other than 0 (not XORA)
0380: C9              RET                         ; Out
*/
}
  
  
in rom @ 0x381 {
// Handle player moving right

  MovePlayerRight:
  a = b;
  cmp(a,0xd9);
  ^goto (0x36F as func) if zero;
  a++;
  playerXr = a;
  ^goto (0x36F as func);
/*
0381: 78              LD      A,B                 ; Player coordinate
0382: FE D9           CP      $D9                 ; At right edge?
0384: CA 6F 03        JP      Z,$036F             ; Yes ... ignore this
0387: 3C              INC     A                   ; Bump X coordinate
0388: 32 1B 20        LD      (playerXr),A        ; New X coordinate
038B: C3 6F 03        JP      $036F               ; Draw player and out
  */ 
}
  
in rom @ 0x38E {
// Handle player moving left

  MovePlayerLeft: 
  a = b;
  cmp(a,0x30);
  ^goto 0x36F as func if zero;
  a--;
  playerXr = a;
  ^goto 0x36f as func;
/*
038E: 78              LD      A,B                 ; Player coordinate
038F: FE 30           CP      $30                 ; At left edge
0391: CA 6F 03        JP      Z,$036F             ; Yes ... ignore this
0394: 3D              DEC     A                   ; Bump X coordinate
0395: 32 1B 20        LD      (playerXr),A        ; New X coordinate
0398: C3 6F 03        JP      $036F               ; Draw player and out
*/  
}
in rom @ 0x39B {
// Toggle the player's blowing-up sprite between two pictures and draw it
  DrawPlayerDie:
  a++;
  a = a & 1;
  playerAlive = a;
  const data3A1 : [u8] = [7,7,7,7];
  hl = 0x1C70;
  a += l;
  l = a;
  plyrSprPic16 = hl;
  ^goto 0x36F as func;
/*
039B: 3C              INC     A                   ; Toggle blowing-up ...
039C: E6 01           AND     $01                 ; ... player sprite (0,1,0,1)
039E: 32 15 20        LD      (playerAlive),A     ; Hold current state
03A1: 07              RLCA                        ; *2
03A2: 07              RLCA                        ; *4
03A3: 07              RLCA                        ; *8
03A4: 07              RLCA                        ; *16
03A5: 21 70 1C        LD      HL,$1C70            ; Base blow-up sprite location
03A8: 85              ADD     A,L                 ; Offset sprite ...
03A9: 6F              LD      L,A                 ; ... pointer
03AA: 22 18 20        LD      (plyrSprPicL),HL    ; New blow-up sprite picture
03AD: C3 6F 03        JP      $036F               ; Draw new blow-up sprite and out
*/

  ^goto 0x34A as func if !zero;
  hl++;
  --*(hl as *u8);
  ^goto 0x34A as func if !zero;
  ^goto 0x346 as func;
/*
03B0: C2 4A 03        JP      NZ,$034A            ; Alien shots enabled ... move player's ship, draw it, and out
03B3: 23              INC     HL                  ; To 206A
03B4: 35              DEC     (HL)                ; Time until aliens can fire
03B5: C2 4A 03        JP      NZ,$034A            ; Not time to enable ... move player's ship, draw it, and out
03B8: C3 46 03        JP      $0346               ; Enable alien fire ... move player's ship, draw it, and out
*/
}

in rom @ 0x3BB {
/*
; Game object 1: Move/draw the player shot
;
; This task executes at either mid-screen ISR (if it is on the top half of the non-rotated screen) or
; at the end-screen ISR (if it is on the bottom half of the screen).
;
*/
  GameObj1:
  de = 0x202A;
  CompYToBeam();
  hl = pop();
  return if !carry;
/*
03BB: 11 2A 20        LD      DE,$202A            ; Object's Yn coordiante
03BE: CD 06 1A        CALL    CompYToBeam         ; Compare to screen-update location
03C1: E1              POP     HL                  ; Pointer to task data
03C2: D0              RET     NC                  ; Make sure we are in the right ISR
*/

  hl++;
  a = *(hl as *u8);
  a = a & a;
  return if zero;
/*
03C3: 23              INC     HL                  ; Point to 2025 ... the shot status
03C4: 7E              LD      A,(HL)              ; Get shot status
03C5: A7              AND     A                   ; Return if ...
03C6: C8              RET     Z                   ; ... no shot is active
*/
  cmp(a,1);
  ^goto InitPlyShot if zero;
/*
03C7: FE 01           CP      $01                 ; Shot just starting (requested elsewhere)?
03C9: CA FA 03        JP      Z,InitPlyShot       ; Yes ... go initiate shot
*/
  cmp(a,2);
  ^goto MovePlyShot if zero;
/*
03CC: FE 02           CP      $02                 ; Progressing normally?
03CE: CA 0A 04        JP      Z,MovePlyShot       ; Yes ... go move it
*/
  hl++;
  cmp(a,3);
  ^goto (0x42A as func) if !zero;
/*  
03D1: 23              INC     HL                  ; 2026
03D2: FE 03           CP      $03                 ; Shot blowing up (not because of alien)?
03D4: C2 2A 04        JP      NZ,$042A            ; No ... try other options  
  */
}
  
in rom @ 0x3D7 {
// Shot blowing up because it left the playfield, hit a shield, or hit another bullet
  --*(hl as *u8);
  ^goto EndOfBlowup if zero;
  a = *(hl as *u8);
  cmp(a,0x0f);
  return if !zero;
/*
03D7: 35              DEC     (HL)                ; Decrement the timer
03D8: CA 36 04        JP      Z,EndOfBlowup       ; If done then
03DB: 7E              LD      A,(HL)              ; Get timer value
03DC: FE 0F           CP      $0F                 ; Starts at 10 ... first decrement brings us here
03DE: C0              RET     NZ                  ; Not the first time ... explosion has been drawn  
*/  
}
  
in rom @ 0x3DF {
// Draw explosion first pass through timer loop
  push(hl);
  ReadPlyShot();
  EraseShifted();
  hl = pop();
  hl++;
  ++*(hl as *u8);
  hl++;
  hl++;
  --*(hl as *u8);
  --*(hl as *u8);
  hl++;
  --*(hl as *u8);
  --*(hl as *u8);
  --*(hl as *u8);
  hl++;
  *(hl as *u8) = 0x08;
  ReadPlyShot();
  ^goto DrawShiftedSprite;
/*
03DF: E5              PUSH    HL                  ; Hold pointer to data
03E0: CD 30 04        CALL    ReadPlyShot         ; Read shot descriptor
03E3: CD 52 14        CALL    EraseShifted        ; Erase the sprite
03E6: E1              POP     HL                  ; 2026 (timer flag)
03E7: 23              INC     HL                  ; 2027 point to sprite LSB
03E8: 34              INC     (HL)                ; Change 1C90 to 1C91
03E9: 23              INC     HL                  ; 2028
03EA: 23              INC     HL                  ; 2029
03EB: 35              DEC     (HL)                ; Drop X coordinate ...
03EC: 35              DEC     (HL)                ; ... by 2
03ED: 23              INC     HL                  ; 202A
03EE: 35              DEC     (HL)                ; Drop Y ...
03EF: 35              DEC     (HL)                ; ... coordinate ...
03F0: 35              DEC     (HL)                ; ... by ...
03F1: 23              INC     HL                  ; ... 3
03F2: 36 08           LD      (HL),$08            ; 202B 8 bytes in size of sprite
03F4: CD 30 04        CALL    ReadPlyShot         ; Read player shot structure
03F7: C3 00 14        JP      DrawShiftedSprite   ; Draw sprite and out
*/
  
}
in rom @ 0x3FA {
  InitPlyShot:
  a++;
  *(hl as *u8) = a;
  a = playerXr;
  a+=8;
  obj1CoorXr = a;
  ReadPlyShot();
  ^goto DrawShiftedSprite;
/*
03FA: 3C              INC     A                   ; Type is now ...
03FB: 77              LD      (HL),A              ; ... 2 (in progress)
03FC: 3A 1B 20        LD      A,(playerXr)        ; Players Y coordinate
03FF: C6 08           ADD     A,$08               ; To center of player
0401: 32 2A 20        LD      (obj1CoorXr),A      ; Shot's Y coordinate
0404: CD 30 04        CALL    ReadPlyShot         ; Read 5 byte structure
0407: C3 00 14        JP      DrawShiftedSprite   ; Draw sprite and out
*/

  MovePlyShot:
  ReadPlyShot();
  push(de);
  push(hl);
  push(bc);
  EraseShifted();
  bc = pop();
  hl = pop();
  de = pop();
  a = shotDeltaX;
  a = a + l;
  l = a;
  obj1CoorYr = a;
  DrawSprCollision();
  a = collision;
  a = a & a;
  return if zero;
  
/*
040A: CD 30 04        CALL    ReadPlyShot         ; Read the shot structure
040D: D5              PUSH    DE                  ; Hold pointer to sprite image
040E: E5              PUSH    HL                  ; Hold sprite coordinates
040F: C5              PUSH    BC                  ; Hold sprite size (in B)
0410: CD 52 14        CALL    EraseShifted        ; Erase the sprite from the screen
0413: C1              POP     BC                  ; Restore size
0414: E1              POP     HL                  ; Restore coords
0415: D1              POP     DE                  ; Restore pointer to sprite image
0416: 3A 2C 20        LD      A,(shotDeltaX)      ; DeltaX for shot
0419: 85              ADD     A,L                 ; Move the shot ...
041A: 6F              LD      L,A                 ; ... up the screen
041B: 32 29 20        LD      (obj1CoorYr),A      ; Store shot's new X coordinate
041E: CD 91 14        CALL    DrawSprCollision    ; Draw sprite with collision detection
0421: 3A 61 20        LD      A,(collision)       ; Test for ...
0424: A7              AND     A                   ; ... collision
0425: C8              RET     Z                   ; No collision ... out  
*/  
}
  
in rom @ 0x426 {
// Collision with alien detected
  alienIsExploding = a;
  return;
/*0426: 32 02 20        LD      (alienIsExploding),A; Set to not-0 indicating ...
0429: C9              RET          
  */
// Other shot-status options
  cmp(a,5);
  return if zero;
  ^goto EndOfBlowup;
/*
042A: FE 05           CP      $05                 ; Alien explosion in progress?
042C: C8              RET     Z                   ; Yes ... nothing to do
042D: C3 36 04        JP      EndOfBlowup         ; Anything else erases the shot and removes it from duty
*/
}
  
in rom @ 0x430 {
 ReadPlyShot:
  hl = 0x2027;
  ^goto ReadDesc;
  /*
0430: 21 27 20        LD      HL,$2027            ; Read 5 byte sprite structure for ...
0433: C3 3B 1A        JP      ReadDesc            ; ... player shot
 */
}
  
in rom @ 0x436 {
EndOfBlowup:
  ReadPlyShot();
  EraseShifted();
  hl = 0x2025;
  de = 0x1B25;
  b = 0x07;
  BlockCopy();
  hl = sauScore;
  l++;
  a = l;
  cmp(a,0x63);
  ^if !carry {
   l = 0x54;
  }
  sauScore = hl;
  hl = shotCount;
  l++;
  shotCount = hl;
/*
0436: CD 30 04        CALL    ReadPlyShot         ; Read the shot structure
0439: CD 52 14        CALL    EraseShifted        ; Erase the player's shot
043C: 21 25 20        LD      HL,$2025            ; Reinit ...
043F: 11 25 1B        LD      DE,$1B25            ; ... shot structure ...
0442: 06 07           LD      B,$07               ; ... from ...
0444: CD 32 1A        CALL    BlockCopy           ; ... ROM mirror
0447: 2A 8D 20        LD      HL,(sauScoreLSB)    ; Get pointer to saucer-score table
044A: 2C              INC     L                   ; Every shot explosion advances it one
044B: 7D              LD      A,L                 ; Have we passed ...
044C: FE 63           CP      $63                 ; ... the end at 1D63 (bug! this should be $64 to cover all 16 values)
044E: DA 53 04        JP      C,$0453             ; No .... keep it
0451: 2E 54           LD      L,$54               ; Wrap back around to 1D54
0453: 22 8D 20        LD      (sauScoreLSB),HL    ; New score pointer
0456: 2A 8F 20        LD      HL,(shotCountLSB)   ; Increments with every shot ...
0459: 2C              INC     L                   ; ... but only LSB ** ...
045A: 22 8F 20        LD      (shotCountLSB),HL   ; ... used for saucer direction
*/
  a = saucerActive;
  a = a & a;
  return if !zero;
/*
045D: 3A 84 20        LD      A,(saucerActive)    ; Is saucer ...
0460: A7              AND     A                   ; ... on screen?
0461: C0              RET     NZ                  ; Yes ... don't reset it
;  
 */ 
}
  
in rom @ 0x462 {
// Setup saucer direction for next trip
  a = *(hl as *u8);
  a = a & 1;
  bc = 0x229;
  ^if zero {
    bc = 0xFEE0;
  }
  hl = 0x208A;
  *(hl as *u8) = c;
  hl++;
  hl++;
  *(hl as *u8) = b;
  return;
/*
0462: 7E              LD      A,(HL)              ; Shot counter
0463: E6 01           AND     $01                 ; Lowest bit set?
0465: 01 29 02        LD      BC,$0229            ; Xr delta of 2 starting at Xr=29
0468: C2 6E 04        JP      NZ,$046E            ; Yes ... use 2/29
046B: 01 E0 FE        LD      BC,$FEE0            ; No ... Xr delta of -2 starting at Xr=E0
046E: 21 8A 20        LD      HL,$208A            ; Saucer descriptor
0471: 71              LD      (HL),C              ; Store Xr coordinate
0472: 23              INC     HL                  ; Point to ...
0473: 23              INC     HL                  ; ... delta Xr
0474: 70              LD      (HL),B              ; Store delta Xr
0475: C9              RET                         ; Done
 */ 
}
  
in rom @ 0x476 {
/*
; Game object 2: Alien rolling-shot (targets player specifically)
;
; The 2-byte value at 2038 is where the firing-column-table-pointer would be (see other
; shots ... next game objects). This shot doesn't use that table. It targets the player
; specifically. Instead the value is used as a flag to have the shot skip its first
; attempt at firing every time it is reinitialized (when it blows up).
;
; The task-timer at 2032 is copied to 2080 in the game loop. The flag is used as a
; synchronization flag to keep all the shots processed on separate interrupt ticks. This
; has the main effect of slowing the shots down.
;
; When the timer is 2 the squiggly-shot/saucer (object 4 ) runs.
; When the timer is 1 the plunger-shot (object 3) runs.
; When the timer is 0 this object, the rolling-shot, runs.
*/
    GameObj2:
  hl = pop();
  a = *(0x1b32 as *u8);
  obj2TimerExtra = a;
  hl = rolShotCFir;
  a = l;
  a = a | h;
  ^if zero {
    hl--;
    rolShotCFir = hl;
    return;
  }
/*
0476: E1              POP     HL                  ; Game object data
0477: 3A 32 1B        LD      A,($1B32)           ; Restore delay from ...
047A: 32 32 20        LD      (obj2TimerExtra),A  ; ... ROM mirror (value 2)
047D: 2A 38 20        LD      HL,(rolShotCFirLSB) ; Get pointer to ...
0480: 7D              LD      A,L                 ; ... column-firing table.
0481: B4              OR      H                   ; All zeros?
0482: C2 8A 04        JP      NZ,$048A            ; No ... must be a valid column. Go fire.
0485: 2B              DEC     HL                  ; Decrement the counter
0486: 22 38 20        LD      (rolShotCFirLSB),HL ; Store new counter value (run the shot next time)
0489: C9              RET                         ; And out
*/
  de = 0x2035;
  a = 0xf9;
  ToShotStruct();
  a = pluShotStepCnt;
  otherShot1 = a;
  a = squShotStepCnt;
  otherShot2 = a;
  HandleAlienShot();
  a = aShotBlowCnt;
  a = a & a;
  hl = 0x2035;
  ^goto FromShotStruct if !zero;
/*
048A: 11 35 20        LD      DE,$2035            ; Rolling-shot data structure
048D: 3E F9           LD      A,$F9               ; Last picture of "rolling" alien shot
048F: CD 50 05        CALL    ToShotStruct        ; Set code to handle rolling-shot
0492: 3A 46 20        LD      A,(pluShotStepCnt)  ; Get the plunger-shot step count
0495: 32 70 20        LD      (otherShot1),A      ; Hold it
0498: 3A 56 20        LD      A,(squShotStepCnt)  ; Get the squiggly-shot step count
049B: 32 71 20        LD      (otherShot2),A      ; Hold it
049E: CD 63 05        CALL    HandleAlienShot     ; Handle active shot structure
04A1: 3A 78 20        LD      A,(aShotBlowCnt)    ; Blow up counter
04A4: A7              AND     A                   ; Test if shot has cycled through blowing up
04A5: 21 35 20        LD      HL,$2035            ; Rolling-shot data structure
04A8: C2 5B 05        JP      NZ,FromShotStruct   ; If shot is still running, copy the updated data and out
*/
}
 
in rom @ 0x4AB {
// The rolling-shot has blown up. Reset the data structure.
  ResetShot:
  de = 0x1b30;
  hl = 0x2030;
  b = 0x10;
  ^goto BlockCopy;
/*
04AB: 11 30 1B        LD      DE,$1B30            ; Reload ...
04AE: 21 30 20        LD      HL,$2030            ; ... object ...
04B1: 06 10           LD      B,$10               ; ... structure ...
04B3: C3 32 1A        JP      BlockCopy           ; ... from ROM mirror and out
*/
}
  
in rom @ 0x4B6 {
/*
; Game object 3: Alien plunger-shot
; This is skipped if there is only one alien left on the screen.
*/

  GameObj3:
  hl = pop();
  a = skipPlunger;
  a = a & a;
  return if !zero;
  a = shotSync;
  cmp(a,1);
  return if !zero;
/*
04B6: E1              POP     HL                  ; Game object data
04B7: 3A 6E 20        LD      A,(skipPlunger)     ; One alien left? Skip plunger shot?
04BA: A7              AND     A                   ; Check
04BB: C0              RET     NZ                  ; Yes. Only one alien. Skip this shot.
04BC: 3A 80 20        LD      A,(shotSync)        ; Sync flag (copied from GO-2's timer value)
04BF: FE 01           CP      $01                 ; GO-2 and GO-4 are idle?
04C1: C0              RET     NZ                  ; No ... only one shot at a time
*/
  de = 0x2045;
  a = 0xed;
  ToShotStruct();
  a = rolShotStepCnt;
  otherShot1 = a;
  a = squShotStepCnt;
  otherShot2 = a;
  HandleAlienShot();
  a = aShotCFirLSB;
  cmp(a,0x10);
  ^if !carry {
    a = *(0x1B48 as *u8);
    aShotCFirLSB = a;
  }
  a = aShotBlowCnt;
  a = a & a;
  hl = 0x2045;
  ^goto FromShotStruct if !zero;
  
/*
04C2: 11 45 20        LD      DE,$2045            ; Plunger alien shot data structure
04C5: 3E ED           LD      A,$ED               ; Last picture of "plunger" alien shot
04C7: CD 50 05        CALL    ToShotStruct        ; Copy the plunger alien to the active structure
04CA: 3A 36 20        LD      A,(rolShotStepCnt)  ; Step count from rolling-shot
04CD: 32 70 20        LD      (otherShot1),A      ; Hold it
04D0: 3A 56 20        LD      A,(squShotStepCnt)  ; Step count from squiggly shot
04D3: 32 71 20        LD      (otherShot2),A      ; Hold it
04D6: CD 63 05        CALL    HandleAlienShot     ; Handle active shot structure
04D9: 3A 76 20        LD      A,(aShotCFirLSB)    ; LSB of column-firing table
04DC: FE 10           CP      $10                 ; Been through all entries in the table?
04DE: DA E7 04        JP      C,$04E7             ; Not yet ... table is OK
04E1: 3A 48 1B        LD      A,($1B48)           ; Been through all ..
04E4: 32 76 20        LD      (aShotCFirLSB),A    ; ... so reset pointer into firing-column table
04E7: 3A 78 20        LD      A,(aShotBlowCnt)    ; Get the blow up timer
04EA: A7              AND     A                   ; Zero means shot is done
04EB: 21 45 20        LD      HL,$2045            ; Plunger shot data
04EE: C2 5B 05        JP      NZ,FromShotStruct   ; If shot is still running, go copy the updated data and out
*/
  
  de = 0x1B40;
  hl = 0x2040;
  b = 0x10;
  BlockCopy();
/*
04F1: 11 40 1B        LD      DE,$1B40            ; Reload ...
04F4: 21 40 20        LD      HL,$2040            ; ... object ...
04F7: 06 10           LD      B,$10               ; ... structure ...
04F9: CD 32 1A        CALL    BlockCopy           ; ... from mirror
*/
  a = numAliens;
  a--;
  ^if zero {
    a = 1;
    skipPlunger = a;
  }
  hl = aShotCFir;
  ^goto 0x67E as func;
/*
04FC: 3A 82 20        LD      A,(numAliens)       ; Number of aliens on screen
04FF: 3D              DEC     A                   ; Is there only one left?
0500: C2 08 05        JP      NZ,$0508            ; No ... move on
0503: 3E 01           LD      A,$01               ; Disable plunger shot ...
0505: 32 6E 20        LD      (skipPlunger),A     ; ... when only one alien remains
0508: 2A 76 20        LD      HL,(aShotCFirLSB)   ; Set the plunger shot's ...
050B: C3 7E 06        JP      $067E               ; ... column-firing pointer data
*/
}

  
in rom @ 0x50E {
// Game task 4 when splash screen alien is shooting extra "C" with a squiggly shot
  hl = pop();
/*
050E: E1              POP     HL                  ; Ignore the task data pointer passed on stack
*/

// GameObject 4 comes here if processing a squiggly shot
  de = 0x2055;
  a = 0xDB;
  ToShotStruct();
  a = pluShotStepCnt;
  otherShot1 = a;
  a = rolShotStepCnt;
  otherShot2 = a;
  HandleAlienShot();
  a = aShotCFirLSB;
  cmp(a,0x15);
  ^if !carry {
    a = *(0x1b58 as *u8);
    aShotCFirLSB = a;
  }
  a = aShotBlowCnt;
  a = a & a;
  hl = 0x2055;
  ^goto FromShotStruct if !zero;
/*
050F: 11 55 20        LD      DE,$2055            ; Squiggly shot data structure
0512: 3E DB           LD      A,$DB               ; LSB of last byte of picture
0514: CD 50 05        CALL    ToShotStruct        ; Copy squiggly shot to
0517: 3A 46 20        LD      A,(pluShotStepCnt)  ; Get plunger ...
051A: 32 70 20        LD      (otherShot1),A      ; ... step count
051D: 3A 36 20        LD      A,(rolShotStepCnt)  ; Get rolling ...
0520: 32 71 20        LD      (otherShot2),A      ; ... step count
0523: CD 63 05        CALL    HandleAlienShot     ; Handle active shot structure
0526: 3A 76 20        LD      A,(aShotCFirLSB)    ; LSB of column-firing table pointer
0529: FE 15           CP      $15                 ; Have we processed all entries?
052B: DA 34 05        JP      C,$0534             ; No ... don't reset it
052E: 3A 58 1B        LD      A,($1B58)           ; Reset the pointer ...
0531: 32 76 20        LD      (aShotCFirLSB),A    ; ... back to the start of the table
0534: 3A 78 20        LD      A,(aShotBlowCnt)    ; Check to see if squiggly shot is done
0537: A7              AND     A                   ; 0 means blow-up timer expired
0538: 21 55 20        LD      HL,$2055            ; Squiggly shot data structure
053B: C2 5B 05        JP      NZ,FromShotStruct   ; If shot is still running, go copy the updated data and out
*/
}
  
in rom @ 0x53E {
//; Shot explosion is over. Remove the shot.
  de = 0x1B50;
  hl = 0x2050;
  b = 0x10;
  BlockCopy();
  hl = aShotCFir;
  squShotCFir = hl;
  return;
/*
053E: 11 50 1B        LD      DE,$1B50            ; Reload
0541: 21 50 20        LD      HL,$2050            ; ... object ...
0544: 06 10           LD      B,$10               ; ... structure ...
0546: CD 32 1A        CALL    BlockCopy           ; ... from mirror
0549: 2A 76 20        LD      HL,(aShotCFirLSB)   ; Copy pointer to column-firing table ...
054C: 22 58 20        LD      (squShotCFirLSB),HL ; ... back to data structure (for next shot)
054F: C9              RET                         ; Done
*/  
}
  
  
in rom @ 0x550 {
ToShotStruct:
  shotPicEnd = a;
  hl = 0x2073;
  b = 0xb;
  ^goto BlockCopy;
/*
0550: 32 7F 20        LD      (shotPicEnd),A      ; LSB of last byte of last picture in sprite
0553: 21 73 20        LD      HL,$2073            ; Destination is the shot-structure
0556: 06 0B           LD      B,$0B               ; 11 bytes
0558: C3 32 1A        JP      BlockCopy           ; Block copy and out
*/
  
}
 
in rom @ 0x55B {
FromShotStruct:
  de = 0x2073;
  b = 0x0b;
  ^goto BlockCopy;
/*
055B: 11 73 20        LD      DE,$2073            ; Source is the shot-structure
055E: 06 0B           LD      B,$0B               ; 11 bytes
0560: C3 32 1A        JP      BlockCopy           ; Block copy and out
*/  
  
}
  
  
in rom @ 0x563 {
/*
; Each of the 3 shots copy their data to the 2073 structure (0B bytes) and call this.
; Then they copy back if the shot is still active. Otherwise they copy from the mirror.
;
; The alien "fire rate" is based on the number of steps the other two shots on the screen
; have made. The smallest number-of-steps is compared to the reload-rate. If it is too
; soon then no shot is made. The reload-rate is based on the player's score. The MSB
; is looked up in a table to get the reload-rate. The smaller the rate the faster the
; aliens fire. Setting rate this way keeps shots from walking on each other.
*/
  HandleAlienShot:
  hl = 0x2073;
  a = *(hl as *u8);
  a = a & 0x80;
  ^goto (0x5C1 as func) if !zero;
  a = isrSplashTask;
  cmp(a,0x04);
  a = enableAlienFire;
  ^goto (0x5B7 as func) if zero;
  a = a & a;
  return if zero;
/*
0563: 21 73 20        LD      HL,$2073            ; Start of active shot structure
0566: 7E              LD      A,(HL)              ; Get the shot status
0567: E6 80           AND     $80                 ; Is the shot active?
0569: C2 C1 05        JP      NZ,$05C1            ; Yes ... go move it

056C: 3A C1 20        LD      A,(isrSplashTask)   ; ISR splash task
056F: FE 04           CP      $04                 ; Shooting the "C" ?
0571: 3A 69 20        LD      A,(enableAlienFire) ; Alien fire enabled flag
0574: CA B7 05        JP      Z,$05B7             ; We are shooting the extra "C" ... just flag it active and out
0577: A7              AND     A                   ; Is alien fire enabled?
0578: C8              RET     Z                   ; No ... don't start a new shot
*/
  hl++;
  *(hl as *u8) = 0;
/*
0579: 23              INC     HL                  ; 2074 step count of current shot
057A: 36 00           LD      (HL),$00            ; clear the step count
  */
}
  
in rom @ 0x57C {
// Make sure it isn't too soon to fire another shot
  a = otherShot1;
  a = a & a;
  ^if !zero {
    b = a;
    a = aShotReloadRate;
    cmp(a,b);
    return if !carry;
  }
  a = otherShot2;
  a = a & a;
  ^if !zero {
    b = a;
    a = aShotReloadRate;
    cmp(a,b);
    return if !carry;
  }
  hl++;
  a = *(hl as *u8);
  a = a & a;
  ^goto (0x61B as func) if zero;
  hl = aShotCFir;
  c = *(hl as *u8);
  hl++;
  nop();
  aShotCFir = hl;
  FindInColumn();
  return if !carry;
/*
057C: 3A 70 20        LD      A,(otherShot1)      ; Get the step count of the 1st "other shot"
057F: A7              AND     A                   ; Any steps made?
0580: CA 89 05        JP      Z,$0589             ; No ... ignore this count
0583: 47              LD      B,A                 ; Shuffle off step count
0584: 3A CF 20        LD      A,(aShotReloadRate) ; Get the reload rate (based on MSB of score)
0587: B8              CP      B                   ; Too soon to fire again?
0588: D0              RET     NC                  ; Yes ... don't fire
0589: 3A 71 20        LD      A,(otherShot2)      ; Get the step count of the 2nd "other shot"
058C: A7              AND     A                   ; Any steps made?
058D: CA 96 05        JP      Z,$0596             ; No steps on any shot ... we are clear to fire
0590: 47              LD      B,A                 ; Shuffle off step count
0591: 3A CF 20        LD      A,(aShotReloadRate) ; Get the reload rate (based on MSB of score)
0594: B8              CP      B                   ; Too soon to fire again?
0595: D0              RET     NC                  ; Yes ... don't fire
0596: 23              INC     HL                  ; 2075
0597: 7E              LD      A,(HL)              ; Get tracking flag
0598: A7              AND     A                   ; Does this shot track the player?
0599: CA 1B 06        JP      Z,$061B             ; Yes ... go make a tracking shot;
059C: 2A 76 20        LD      HL,(aShotCFirLSB)   ; Column-firing table
059F: 4E              LD      C,(HL)              ; Get next column to fire from
05A0: 23              INC     HL                  ; Bump the ...
05A1: 00              NOP                         ; % WHY?
05A2: 22 76 20        LD      (aShotCFirLSB),HL   ; ... pointer into column table
05A5: CD 2F 06        CALL    FindInColumn        ; Find alien in target column
05A8: D0              RET     NC                  ; No alien is alive in target column ... out
*/
  GetAlienCoords();
  a = c;
  a = a + 7;
  h = a;
  a = l;
  a = a - 0x0a;
  l = a;
  alienShotCr = hl;
/*
05A9: CD 7A 01        CALL    GetAlienCoords      ; Get coordinates of alien (lowest alien in firing column)
05AC: 79              LD      A,C                 ; Offset ...
05AD: C6 07           ADD     A,$07               ; ... Y by 7
05AF: 67              LD      H,A                 ; To H
05B0: 7D              LD      A,L                 ; Offset ...
05B1: D6 0A           SUB     $0A                 ; ... X down 10
05B3: 6F              LD      L,A                 ; To L
05B4: 22 7B 20        LD      (alienShotYr),HL    ; Set shot coordinates below alien
*/
  hl = 0x2073;
  a = *(hl as *u8);
  a = a | 0x80;
  *(hl as *u8) = a;
  hl++;
  ++*(hl as *u8);
  return;
/*
05B7: 21 73 20        LD      HL,$2073            ; Alien shot status
05BA: 7E              LD      A,(HL)              ; Get the status
05BB: F6 80           OR      $80                 ; Mark this shot ...
05BD: 77              LD      (HL),A              ; ... as actively running
05BE: 23              INC     HL                  ; 2074 step count
05BF: 34              INC     (HL)                ; Give this shot 1 step (it just started)
05C0: C9              RET                         ; Out
*/
}
  
in rom @ 0x5C1 {
/*
; Move the alien shot
*/
  de = 0x207C;
  CompYToBeam();
  return if !carry;
  /*
05C1: 11 7C 20        LD      DE,$207C            ; Alien-shot Y coordinate
05C4: CD 06 1A        CALL    CompYToBeam         ; Compare to beam position
05C7: D0              RET     NC                  ; Not the right ISR for this shot
*/
  hl++;
  a = *(hl as *u8);
  a = a & 1;
  ^goto ShotBlowingUp if !zero;
  hl++;
  ++*(hl as *u8);
  (0x675 as func)();
  a = aShotImageLSB;
  a = a + 3;
  hl = 0x207F;
  cmp(a,*(hl as *u8));
  ^if !carry {
   a = a - 0xc; 
  }
  aShotImageLSB = a;
  a = alienShotYr;
  b = a;
  a = alienShotDelta;
  a = a + b;
  alienShotYr = a;
  (0x66C as func)();
  a = alienShotYr;
  cmp(a,0x15);
  ^goto 0x612 as func if carry;
  a = collision;
  a = a & a;
  return if zero;
  a = alienShotYr;
  cmp(a,0x1e);
  ^goto 0x612 as func if carry;
  cmp(a,0x27);
  nop();
  ^goto (0x612 as func) if !carry;
  a = a - a;
  playerAlive = a;
/*
05C8: 23              INC     HL                  ; 2073 status
05C9: 7E              LD      A,(HL)              ; Get shot status
05CA: E6 01           AND     $01                 ; Bit 0 is 1 if blowing up
05CC: C2 44 06        JP      NZ,ShotBlowingUp    ; Go do shot-is-blowing-up sequence
05CF: 23              INC     HL                  ; 2074 step count
05D0: 34              INC     (HL)                ; Count the steps (used for fire rate)
05D1: CD 75 06        CALL    $0675               ; Erase shot
05D4: 3A 79 20        LD      A,(aShotImageLSB)   ; Get LSB of the image pointer
05D7: C6 03           ADD     A,$03               ; Next set of images
05D9: 21 7F 20        LD      HL,$207F            ; End of image
05DC: BE              CP      (HL)                ; Have we reached the end of the set?
05DD: DA E2 05        JP      C,$05E2             ; No ... keep it
05E0: D6 0C           SUB     $0C                 ; Back up to the 1st image in the set
05E2: 32 79 20        LD      (aShotImageLSB),A   ; New LSB image pointer
05E5: 3A 7B 20        LD      A,(alienShotYr)     ; Get shot's Y coordinate
05E8: 47              LD      B,A                 ; Hold it
05E9: 3A 7E 20        LD      A,(alienShotDelta)  ; Get alien shot delta
05EC: 80              ADD     A,B                 ; Add to shots coordinate
05ED: 32 7B 20        LD      (alienShotYr),A     ; New shot Y coordinate
05F0: CD 6C 06        CALL    $066C               ; Draw the alien shot
05F3: 3A 7B 20        LD      A,(alienShotYr)     ; Shot's Y coordinate
05F6: FE 15           CP      $15                 ; Still in the active playfield?
05F8: DA 12 06        JP      C,$0612             ; No ... end it
05FB: 3A 61 20        LD      A,(collision)       ; Did shot collide ...
05FE: A7              AND     A                   ; ... with something?
05FF: C8              RET     Z                   ; No ... we are done here
0600: 3A 7B 20        LD      A,(alienShotYr)     ; Shot's Y coordinate
0603: FE 1E           CP      $1E                 ; Is it below player's area?
0605: DA 12 06        JP      C,$0612             ; Yes ... end it
0608: FE 27           CP      $27                 ; Is it above player's area?
060A: 00              NOP                         ; ** WHY?
060B: D2 12 06        JP      NC,$0612            ; Yes ... end it
060E: 97              SUB     A                   ; Flag that player ...
060F: 32 15 20        LD      (playerAlive),A     ; ... has been struck
*/
  a = aShotStatus;
  a = a | 1;
  aShotStatus = a;
  return;
  
/*
0612: 3A 73 20        LD      A,(aShotStatus)     ; Flag to ...
0615: F6 01           OR      $01                 ; ... start shot ...
0617: 32 73 20        LD      (aShotStatus),A     ; ... blowing up
061A: C9              RET                         ; Out
;  
  */
}

in rom @ 0x61B {
//; Start a shot right over the player

  a = playerXr;
  a = a + 8;
  h = a;
  FindColumn();
  a = c;
  cmp(a,0xc);
  ^goto 0x5A5 as func if carry;
  c = 0xb;
  ^goto 0x5A5 as func;
/*
061B: 3A 1B 20        LD      A,(playerXr)        ; Player's X coordinate
061E: C6 08           ADD     A,$08               ; Center of player
0620: 67              LD      H,A                 ; To H for routine
0621: CD 6F 15        CALL    FindColumn          ; Find the column
0624: 79              LD      A,C                 ; Get the column right over player
0625: FE 0C           CP      $0C                 ; Is it a valid column?
0627: DA A5 05        JP      C,$05A5             ; Yes ... use what we found
062A: 0E 0B           LD      C,$0B               ; Else use ...
062C: C3 A5 05        JP      $05A5               ; ... as far over as we can
*/
  
}
in rom @ 0x62F {
/*
; C contains the target column. Look for a live alien in the column starting with
; the lowest position. Return C=1 if found ... HL points to found slot.
*/
  FindInColumn:
    c--;
    a = playerDataMSB;
    h = a;
    l = c;
    d = 5;
    ^do {
    a = *(hl as *u8);
    a = a & a;
      const data639 : u8 = 0x37; //    carry = false;
    return if !zero;
    a = l;
    a = a + 0x0b;
    l = a;
    d--;
    } while !zero;
    return;
    /*
062F: 0D              DEC     C                   ; Column that is firing
0630: 3A 67 20        LD      A,(playerDataMSB)   ; Player's MSB (21xx or 22xx)
0633: 67              LD      H,A                 ; To MSB of HL
0634: 69              LD      L,C                 ; Column to L
0635: 16 05           LD      D,$05               ; 5 rows of aliens
0637: 7E              LD      A,(HL)              ; Get alien's status
0638: A7              AND     A                   ; 0 means dead
0639: 37              SCF                         ; In case not 0
063A: C0              RET     NZ                  ; Alien is alive? Yes ... return
063B: 7D              LD      A,L                 ; Get the flag pointer LSB
063C: C6 0B           ADD     A,$0B               ; Jump to same column on next row of rack (+11 aliens per row)
063E: 6F              LD      L,A                 ; New alien index
063F: 15              DEC     D                   ; Tested all rows?
0640: C2 37 06        JP      NZ,$0637            ; No ... keep looking for a live alien up the rack
0643: C9              RET                         ; Didn't find a live alien. Return with C=0.
  */

}

in rom @ 0x644 {
// Alien shot is blowing up
  ShotBlowingUp:
  hl = 0x2078;
  --*(hl as *u8);
  a = *(hl as *u8);
  cmp(a,3);
  ^if zero {
    (0x675 as func)();
    hl = 0x1CDC;
    aShotImage = hl;
    hl = 0x207C;
    --*(hl as *u8);
    --*(hl as *u8);
    hl--;
    --*(hl as *u8);
    --*(hl as *u8);
    a = 6;
    alienShotSize = a;
    ^goto 0x66c as func;
  }
/*
0644: 21 78 20        LD      HL,$2078            ; Blow up timer
0647: 35              DEC     (HL)                ; Decrement the value
0648: 7E              LD      A,(HL)              ; Get the value
0649: FE 03           CP      $03                 ; First tick, 4, we draw the explosion
064B: C2 67 06        JP      NZ,$0667            ; After that just wait
064E: CD 75 06        CALL    $0675               ; Erase the shot
0651: 21 DC 1C        LD      HL,$1CDC            ; Alien shot ...
0654: 22 79 20        LD      (aShotImageLSB),HL  ; ... explosion sprite
0657: 21 7C 20        LD      HL,$207C            ; Alien shot Y
065A: 35              DEC     (HL)                ; Left two for ...
065B: 35              DEC     (HL)                ; ... explosion
065C: 2B              DEC     HL                  ; Point slien shot X
065D: 35              DEC     (HL)                ; Up two for ...
065E: 35              DEC     (HL)                ; ... explosion
065F: 3E 06           LD      A,$06               ; Alien shot descriptor ...
0661: 32 7D 20        LD      (alienShotSize),A   ; ... size 6
0664: C3 6C 06        JP      $066C               ; Draw alien shot explosion
*/
  a = a & a;
  return if !zero;
  ^goto 0x675 as func;
  /*
0667: A7              AND     A                   ; Have we reached 0?
0668: C0              RET     NZ                  ; No ... keep waiting
0669: C3 75 06        JP      $0675               ; Erase the explosion and out
*/
  hl = 0x2079;
  ReadDesc();
  ^goto DrawSprCollision;
/*  
066C: 21 79 20        LD      HL,$2079            ; Alien shot descriptor
066F: CD 3B 1A        CALL    ReadDesc            ; Read 5 byte structure
0672: C3 91 14        JP      DrawSprCollision    ; Draw shot and out
*/
  hl = 0x2079;
  ReadDesc();
  ^goto EraseShifted;
  /*
0675: 21 79 20        LD      HL,$2079            ; Alien shot descriptor
0678: CD 3B 1A        CALL    ReadDesc            ; Read 5 byte structure
067B: C3 52 14        JP      EraseShifted        ; Erase the shot and out
*/
  pluShotCFir = hl;
  return;
  /*
067E: 22 48 20        LD      (pluShotCFirLSB),HL ; From 50B, update ...
0681: C9              RET                         ; ... column-firing table pointer and out
  */
  
}
  
in rom @ 0x682 {
/*
; Game object 4: Flying Saucer OR squiggly shot
;
; This task is shared by the squiggly-shot and the flying saucer. The saucer waits until the
; squiggly-shot is over before it begins.
;*/
  GameObj4:
  hl = pop();
  a = shotSync;
  cmp(a,2);
  return if !zero;

  // Why?
  hl = (&saucerStart as u16);
  a = *(hl as *u8);
  a = a & a;
  ^goto (0x50F as func) if zero;
  a = squShotStepCnt;
  a = a & a;
  ^goto (0x50F as func) if !zero;
/*
0682: E1              POP     HL                  ; Pull data pointer from the stack (not going to use it)
0683: 3A 80 20        LD      A,(shotSync)        ; Sync flag (copied from GO-2's timer value)
0686: FE 02           CP      $02                 ; Are GO-2 and GO-3 idle?
0688: C0              RET     NZ                  ; No ... only one at a time
0689: 21 83 20        LD      HL,$2083            ; Time-till-saucer flag
068C: 7E              LD      A,(HL)              ; Is it time ...
068D: A7              AND     A                   ; ... for a saucer?
068E: CA 0F 05        JP      Z,$050F             ; No ... go process squiggly shot
0691: 3A 56 20        LD      A,(squShotStepCnt)  ; Is there a ...
0694: A7              AND     A                   ; ... squiggly shot going?
0695: C2 0F 05        JP      NZ,$050F            ; Yes ... go handle squiggly shot
*/
  hl++;
  a = *(hl as *u8);
  a = a & a;
  ^if zero {
    a = numAliens;
    cmp(a,8);
    ^goto 0x50F as func if carry;
    *(hl as *u8) = 1;
    (0x73C as func)();
  }
  /*
0698: 23              INC     HL                  ; Saucer on screen flag
0699: 7E              LD      A,(HL)              ; (2084) Is the saucer ...
069A: A7              AND     A                   ; ... already on the screen?
069B: C2 AB 06        JP      NZ,$06AB            ; Yes ... go handle it
069E: 3A 82 20        LD      A,(numAliens)       ; Number of aliens remaining
06A1: FE 08           CP      $08                 ; Less than ...
06A3: DA 0F 05        JP      C,$050F             ; ... 8 ... no saucer
06A6: 36 01           LD      (HL),$01            ; (2084) The saucer is on the screen
06A8: CD 3C 07        CALL    $073C               ; Draw the flying saucer
*/
  de = 0x208A;
  CompYToBeam();
  return if !carry;
  /*
06AB: 11 8A 20        LD      DE,$208A            ; Saucer's Y coordinate
06AE: CD 06 1A        CALL    CompYToBeam         ; Compare to beam position
06B1: D0              RET     NC                  ; Not the right ISR for moving saucer
*/
  hl = 0x2085;
  a = *(hl as *u8);
  a = a & a;
  ^if zero {
  /*
06B2: 21 85 20        LD      HL,$2085            ; Saucer hit flag
06B5: 7E              LD      A,(HL)              ; Has saucer ...
06B6: A7              AND     A                   ; ... been hit?
06B7: C2 D6 06        JP      NZ,$06D6            ; Yes ... don't move it
*/
    hl = 0x208A;
    a = *(hl as *u8);
    hl++;
    hl++;
    a += *(hl as *u8);
    saucerPriPicMSB = a;
    (0x73C as func)();
    hl = 0x208A;
    a = *(hl as *u8);
    cmp(a,0x28);
    ^goto (0x6F9 as func) if carry;
    cmp(a,0xe1);
    ^goto (0x6F9 as func) if !carry;   
    /*
06BA: 21 8A 20        LD      HL,$208A            ; Saucer's structure
06BD: 7E              LD      A,(HL)              ; Get saucer's Y coordinate
06BE: 23              INC     HL                  ; Bump to ...
06BF: 23              INC     HL                  ; ... delta Y
06C0: 86              ADD     A,(HL)              ; Move saucer
06C1: 32 8A 20        LD      (saucerPriPicMSB),A ; New coordinate
06C4: CD 3C 07        CALL    $073C               ; Draw the flying saucer
06C7: 21 8A 20        LD      HL,$208A            ; Saucer's structure
06CA: 7E              LD      A,(HL)              ; Y coordinate
06CB: FE 28           CP      $28                 ; Too low? End of screen?
06CD: DA F9 06        JP      C,$06F9             ; Yes ... remove from play
06D0: FE E1           CP      $E1                 ; Too high? End of screen?
06D2: D2 F9 06        JP      NC,$06F9            ; Yes ... remove from play
06D5: C9              RET                         ; Done
*/
    return;
  }
}
  
  
in rom @ 0x6D6 {
  b = 0xfe;
  SoundBits3Off();
  hl++;
  --*(hl as *u8);
  a = *(hl as *u8);
  
  cmp(a,0x1f);
  ^goto (0x74B as func) if zero;

  cmp(a,0x18);
  ^goto (0x70C as func) if zero;
  a = a & a;
  return if !zero;
  b = 0xEF;
  hl = 0x2098;
  a = *(hl as *u8);
  a = a & b;
  *(hl as *u8) = a;
  a = a & 0x20;
  io_write(io.SOUND2, a);
  nop();
  nop();
  nop();
  /*
06D6: 06 FE           LD      B,$FE               ; Turn off ...
06D8: CD DC 19        CALL    SoundBits3Off       ; ... flying saucer sound
06DB: 23              INC     HL                  ; (2086) show-hit timer
06DC: 35              DEC     (HL)                ; Count down show-hit timer
06DD: 7E              LD      A,(HL)              ; Get current value
06DE: FE 1F           CP      $1F                 ; Starts at 20 ... is this the first tick of show-hit timer?
06E0: CA 4B 07        JP      Z,$074B             ; Yes ... go show the explosion
06E3: FE 18           CP      $18                 ; A little later ...
06E5: CA 0C 07        JP      Z,$070C             ; ... show the score besides the saucer and add it
06E8: A7              AND     A                   ; Has timer expired?
06E9: C0              RET     NZ                  ; No ... let it run
06EA: 06 EF           LD      B,$EF               ; 1110_1111 (mask off saucer hit sound)
06EC: 21 98 20        LD      HL,$2098            ; Get current ...
06EF: 7E              LD      A,(HL)              ; ... value of port 5 sound
06F0: A0              AND     B                   ; Mask off the saucer-hit sound
06F1: 77              LD      (HL),A              ; Set the new value
06F2: E6 20           AND     $20                 ; All sound off but ...
06F4: D3 05           OUT     (SOUND2),A          ; ... cocktail cabinet bit
06F6: 00              NOP                         ; ** Why
06F7: 00              NOP                         ; **
06F8: 00              NOP                         ; **
*/
  (0x742 as func)();
  ClearSmallSprite();
  hl = 0x2083;
  b = 0xa;
  (0x75F as func)();
/*
 06F9: CD 42 07        CALL    $0742               ; Covert pixel pos from descriptor to HL screen and shift
06FC: CD CB 14        CALL    ClearSmallSprite    ; Clear a one byte sprite at HL
06FF: 21 83 20        LD      HL,$2083            ; Saucer structure
0702: 06 0A           LD      B,$0A               ; 10 bytes in saucer structure
0704: CD 5F 07        CALL    $075F               ; Re-initialize saucer structure
*/
  b = 0xfe;
  ^goto SoundBits3Off;
/*
0707: 06 FE           LD      B,$FE               ; Turn off UFO ...
0709: C3 DC 19        JP      SoundBits3Off       ; ... sound and out
*/

  a = 1;
  adjustScore = a;
  hl = sauScore;
  b = *(hl as *u8);
  c = 4;
  hl = 0x1d50;
  de = 0x1d4c;
  ^do {
    a = *(de as *u8);
    cmp(a,b);
    ^goto (0x728 as func) if zero;
    hl++;
    de++;
    c--;
  } while !zero;
  a = *(hl as *u8);
  saucerPriLocLSB = a;
  h = 0;
  l = b;
  hl += hl;
  hl += hl;
  hl += hl;
  hl += hl;
  scoreDelta = hl;
  (0x742 as func)();
  ^goto 0x8F1 as func;
  /*
070C: 3E 01           LD      A,$01               ; Flag the score ...
070E: 32 F1 20        LD      (adjustScore),A     ; ... needs updating
0711: 2A 8D 20        LD      HL,(sauScoreLSB)    ; Saucer score table
0714: 46              LD      B,(HL)              ; Get score for this saucer
0715: 0E 04           LD      C,$04               ; There are only 4 possibilities
0717: 21 50 1D        LD      HL,$1D50            ; Possible scores table
071A: 11 4C 1D        LD      DE,$1D4C            ; Print strings for each score
071D: 1A              LD      A,(DE)              ; Find ...
071E: B8              CP      B                   ; ... the ...
071F: CA 28 07        JP      Z,$0728             ; ... print ...
0722: 23              INC     HL                  ; ... string ...
0723: 13              INC     DE                  ; ... for ...
0724: 0D              DEC     C                   ; ... the ...
0725: C2 1D 07        JP      NZ,$071D            ; ... score
0728: 7E              LD      A,(HL)              ; Get LSB of message (MSB is 2088 which is 1D)
0729: 32 87 20        LD      (saucerPriLocLSB),A ; Message's LSB (_50=1D94 100=1D97 150=1D9A 300=1D9D)
072C: 26 00           LD      H,$00               ; MSB = 0 ...
072E: 68              LD      L,B                 ; HL = B
072F: 29              ADD     HL,HL               ; *2
0730: 29              ADD     HL,HL               ; *4
0731: 29              ADD     HL,HL               ; *8
0732: 29              ADD     HL,HL               ; *16
0733: 22 F2 20        LD      (scoreDeltaLSB),HL  ; Add score for hitting saucer (015 becomes 150 in BCD).
0736: CD 42 07        CALL    $0742               ; Get the flying saucer score descriptor
0739: C3 F1 08        JP      $08F1               ; Print the three-byte score and out
*/
  (0x742 as func)();
  ^goto DrawSimpSprite;
  /*
073C: CD 42 07        CALL    $0742               ; Draw the ...
073F: C3 39 14        JP      DrawSimpSprite      ; ... flying saucer
*/
  
  hl = 0x2087;
  ReadDesc();
  ^goto ConvToScr;
  /*
0742: 21 87 20        LD      HL,$2087            ; Read flying saucer ...
0745: CD 3B 1A        CALL    ReadDesc            ; ... structure
0748: C3 47 1A        JP      ConvToScr           ; Convert pixel number to screen and shift and out
*/
  b = 0x10;
  hl = 0x2098;
  a = *(hl as *u8);
  a = a | b;
  *(hl as *u8) = a;
  (0x1770 as func)();
  hl = 0x1D7C;
  saucerPriLoc = hl;
  ^goto (0x73C as func);
  /*
074B: 06 10           LD      B,$10               ; Saucer hit sound bit
074D: 21 98 20        LD      HL,$2098            ; Current state of sounds
0750: 7E              LD      A,(HL)              ; OR ...
0751: B0              OR      B                   ; ... in ...
0752: 77              LD      (HL),A              ; ... saucer-hit sound
0753: CD 70 17        CALL    $1770               ; Turn off fleet sound and start saucer-hit
0756: 21 7C 1D        LD      HL,$1D7C            ; Sprite for saucer blowing up
0759: 22 87 20        LD      (saucerPriLocLSB),HL; Store it in structure
075C: C3 3C 07        JP      $073C               ; Draw the flying saucer
*/
  de = 0x1B83;
  ^goto BlockCopy;
  /*
075F: 11 83 1B        LD      DE,$1B83            ; Data for saucer (702 sets count to 0A)
0762: C3 32 1A        JP      BlockCopy           ; Reset saucer object data
*/
}
  
  
in rom @ 0x765 {
  WaitForStart:
  a = 0x01;
  waitStartLoop = a;
  sp = 0x2400;
  interrupt = true;
  (0x1979 as func)();
  ClearPlayField();
  hl = 0x3013;
  de = 0x1FF3;
  c = 4;
  PrintMessage();
  ^do {
  a = numCoins;
  a--;
  hl = 0x2810;
  c = 0x14;
  ^goto (0x857 as func) if !zero;
  de = 0x1ACF;
  PrintMessage();
  a = io_read(io.INP1);
  a = a & 4;
  } while zero;
  /*; Wait for player 1 start button press
0765: 3E 01           LD      A,$01               ; Tell ISR that we ...
0767: 32 93 20        LD      (waitStartLoop),A   ; ... have started to wait
076A: 31 00 24        LD      SP,$2400            ; Reset stack
076D: FB              EI                          ; Enable interrupts
076E: CD 79 19        CALL    $1979               ; Suspend game tasks
0771: CD D6 09        CALL    ClearPlayField      ; Clear center window
0774: 21 13 30        LD      HL,$3013            ; Screen coordinates
0777: 11 F3 1F        LD      DE,$1FF3            ; "PRESS"
077A: 0E 04           LD      C,$04               ; Message length
077C: CD F3 08        CALL    PrintMessage        ; Print it
077F: 3A EB 20        LD      A,(numCoins)        ; Number of credits
0782: 3D              DEC     A                   ; Set flags
0783: 21 10 28        LD      HL,$2810            ; Screen coordinates
0786: 0E 14           LD      C,$14               ; Message length
0788: C2 57 08        JP      NZ,$0857            ; Take 1 or 2 player start
078B: 11 CF 1A        LD      DE,$1ACF            ; "ONLY 1PLAYER BUTTON "
078E: CD F3 08        CALL    PrintMessage        ; Print message
0791: DB 01           IN      A,(INP1)            ; Read player controls
0793: E6 04           AND     $04                 ; 1Player start button?
0795: CA 7F 07        JP      Z,$077F             ; No ... wait for button or credit
*/
}

  // Start New Game

  
in rom @ 0x798 {
/*
; 1 Player start
*/
  NewGame:
  b = 0x99;
  a = a ^ a;
  /*
0798: 06 99           LD      B,$99               ; Essentially a -1 for DAA
079A: AF              XOR     A                   ; Clear two player flag
*/
/*
; 2 player start sequence enters here with a=1 and B=98 (-2)
*/
  twoPlayers = a;
  a = numCoins;
  a +=b;
  const data_7a2 : u8 = 0x27; // DAA
  numCoins = a;
  DrawNumCredits();
  hl = 0;
  P1Score = hl;
  P2Score = hl;
  (0x1925 as func)();
  (0x192B as func)();
  DisableGameTasks();
  hl = 0x101;
  a = h;
  gameMode = a;
  player1Alive = hl;
  player1Ex = hl;
  DrawStatus();
  DrawShieldPl1();
  DrawShieldPl2();
  GetShipsPerCred();
  p1.ShipsRem = a;
  p2.ShipsRem = a;
  (0xd7 as func)();
  a = a ^ a;
  p1.RackCnt = a;
  p2.RackCnt = a;
  InitAliens();
  InitAliensP2();
  hl = 0x3878;
  p1.RefAlienC = hl;
  p2.RefAlienC = hl;
  CopyRAMMirror();
  RemoveShip();
  /*
079B: 32 CE 20        LD      (twoPlayers),A      ; Set flag for 1 or 2 players
079E: 3A EB 20        LD      A,(numCoins)        ; Number of credits
07A1: 80              ADD     A,B                 ; Take away credits
07A2: 27              DAA                         ; Convert back to DAA
07A3: 32 EB 20        LD      (numCoins),A        ; New credit count
07A6: CD 47 19        CALL    DrawNumCredits      ; Display number of credits
07A9: 21 00 00        LD      HL,$0000            ; Score of 0000
07AC: 22 F8 20        LD      (P1ScorL),HL        ; Clear player-1 score
07AF: 22 FC 20        LD      (P2ScorL),HL        ; Clear player-2 score
07B2: CD 25 19        CALL    $1925               ; Print player-1 score
07B5: CD 2B 19        CALL    $192B               ; Print player-2 score
07B8: CD D7 19        CALL    DsableGameTasks     ; Disable game tasks
07BB: 21 01 01        LD      HL,$0101            ; Two bytes 1, 1
07BE: 7C              LD      A,H                 ; 1 to A
07BF: 32 EF 20        LD      (gameMode),A        ; 20EF=1 ... game mode
07C2: 22 E7 20        LD      (player1Alive),HL   ; 20E7 and 20E8 both one ... players 1 and 2 are alive
07C5: 22 E5 20        LD      (player1Ex),HL      ; Extra-ship is available for player-1 and player-2
07C8: CD 56 19        CALL    DrawStatus          ; Print scores and credits
07CB: CD EF 01        CALL    DrawShieldPl1       ; Draw shields for player-1
07CE: CD F5 01        CALL    DrawShieldPl2       ; Draw shields for player-2
07D1: CD D1 08        CALL    GetShipsPerCred     ; Get number of ships from DIP settings
07D4: 32 FF 21        LD      (p1ShipsRem),A      ; Player-1 ships
07D7: 32 FF 22        LD      (p2ShipsRem),A      ; Player-2 ships
07DA: CD D7 00        CALL    $00D7               ; Set player-1 and player-2 alien racks going right
07DD: AF              XOR     A                   ; Make a 0
07DE: 32 FE 21        LD      (p1RackCnt),A       ; Player 1 is on first rack of aliens
07E1: 32 FE 22        LD      (p2RackCnt),A       ; Player 2 is on first rack of aliens
07E4: CD C0 01        CALL    InitAliens          ; Initialize 55 aliens for player 1
07E7: CD 04 19        CALL    InitAliensP2        ; Initialize 55 aliens for player 2
07EA: 21 78 38        LD      HL,$3878            ; Screen coordinates for lower-left alien
07ED: 22 FC 21        LD      (p1RefAlienY),HL    ; Initialize reference alien for player 1
07F0: 22 FC 22        LD      (p2RefAlienYr),HL   ; Initialize reference alien for player 2
07F3: CD E4 01        CALL    CopyRAMMirror       ; Copy ROM mirror to RAM (2000 - 20C0)
07F6: CD 7F 1A        CALL    RemoveShip          ; Initialize ship hold indicator
*/
  PromptPlayer();
  ClearPlayField();
  nop();
  a = a ^ a;
  isrSplashTask = a;
  DrawBottomLine();
  a = playerDataMSB;
  const data_80a : u8 = 0xf; // RRCA
  ^goto (0x872 as func) if carry;
  /*
07F9: CD 8D 08        CALL    PromptPlayer        ; Prompt with "PLAY PLAYER "
07FC: CD D6 09        CALL    ClearPlayField      ; Clear the playfield
07FF: 00              NOP                         ; % Why?
0800: AF              XOR     A                   ; Make a 0
0801: 32 C1 20        LD      (isrSplashTask),A   ; Disable isr splash-task animation
0804: CD CF 01        CALL    DrawBottomLine      ; Draw line across screen under player
0807: 3A 67 20        LD      A,(playerDataMSB)   ; Current player
080A: 0F              RRCA                        ; Right bit tells all
080B: DA 72 08        JP      C,$0872             ; Go do player 1
*/
  RestoreShields2();
  DrawBottomLine();
  InitRack();
  EnableGameTasks();
  b = 0x20;
  SoundBits3On();
/*
080E: CD 13 02        CALL    RestoreShields2     ; Restore shields for player 2
0811: CD CF 01        CALL    DrawBottomLine      ; Draw line across screen under player
0814: CD B1 00        CALL    InitRack            ; Initialize alien rack for current player
0817: CD D1 19        CALL    EnableGameTasks     ; Enable game tasks in ISR
081A: 06 20           LD      B,$20               ; Enable ...
081C: CD FA 18        CALL    SoundBits3On        ; ... sound amplifier
;  
  */
  
}

  
in rom @ 0x81F {
/*
;
; GAME LOOP
;
*/
  ^do {
    PlrFireOrDemo();
    PlyrShotAndBump();
    CountAliens();
    AdjustScore();
    a = numAliens;
    a = a & a;
    ^goto (0x9EF as func) if zero;
    AShotReloadRate();
    (0x935 as func)();
    SpeedShots();
    ShotSound();
    (0xA59 as func)();
    ^if !zero {
      b = 4;
      SoundBits3On();
    }
    FleetDelayExShip();
    io_write(io.WATCHDOG,a);
    CtrlSaucerSound();
  } while true;
/*
081F: CD 18 16        CALL    PlrFireOrDemo       ; Initiate player shot if button pressed
0822: CD 0A 19        CALL    PlyrShotAndBump     ; Collision detect player's shot and rack-bump
0825: CD F3 15        CALL    CountAliens         ; Count aliens (count to 2082)
0828: CD 88 09        CALL    AdjustScore         ; Adjust score (and print) if there is an adjustment
082B: 3A 82 20        LD      A,(numAliens)       ; Number of live aliens
082E: A7              AND     A                   ; All aliens gone?
082F: CA EF 09        JP      Z,$09EF             ; Yes ... end of turn
0832: CD 0E 17        CALL    AShotReloadRate     ; Update alien-shot-rate based on player's score
0835: CD 35 09        CALL    $0935               ; Check (and handle) extra ship award
0838: CD D8 08        CALL    SpeedShots          ; Adjust alien shot speed
083B: CD 2C 17        CALL    ShotSound           ; Shot sound on or off with 2025
083E: CD 59 0A        CALL    $0A59               ; Check if player is hit
0841: CA 49 08        JP      Z,$0849             ; No hit ... jump handler
0844: 06 04           LD      B,$04               ; Player hit sound
0846: CD FA 18        CALL    SoundBits3On        ; Make explosion sound
0849: CD 75 17        CALL    FleetDelayExShip    ; Extra-ship sound timer, set fleet-delay, play fleet movement sound
084C: D3 06           OUT     (WATCHDOG),A        ; Feed the watchdog
084E: CD 04 18        CALL    CtrlSaucerSound     ; Control saucer sound
0851: C3 1F 08        JP      $081F               ; Continue game loop
*/
  nop();
  nop();
  nop();
/*
0854: 00 00 00                                    ; ** Why?
*/
  
}
  
in rom @ 0x857 {
//  ; Test for 1 or 2 player start button press
  de = 0x1ABA;
  PrintMessage();
  b = 0x98;
  a = io_read(io.INP1);
  const data_861 : [u8;2] = [0xf,0xf]; // RRCA, RRCA
  ^if !carry {
    const data_866 : u8 = 0xf; // RRCA, RRCA
    ^goto NewGame if carry;
    ^goto (0x077f as func);
  }
/*
0857: 11 BA 1A        LD      DE,$1ABA            ; "1 OR 2PLAYERS BUTTON"
085A: CD F3 08        CALL    PrintMessage        ; Print message
085D: 06 98           LD      B,$98               ; -2 (take away 2 credits)
085F: DB 01           IN      A,(INP1)            ; Read player controls
0861: 0F              RRCA                        ; Test ...
0862: 0F              RRCA                        ; ... bit 2
0863: DA 6D 08        JP      C,$086D             ; 2 player button pressed ... do it
0866: 0F              RRCA                        ; Test bit 3
0867: DA 98 07        JP      C,NewGame           ; One player start ... do it
086A: C3 7F 07        JP      $077F               ; Keep waiting on credit or button
*/
//; 2 PLAYER START
  a = 1;
  ^goto (0x79B as func);
/*
086D: 3E 01           LD      A,$01               ; Flag 2 player game
086F: C3 9B 07        JP      $079B               ; Continue normal startup
*/
  RestoreShields1();
  ^goto (0x814 as func);
/*
0872: CD 1A 02        CALL    RestoreShields1     ; Restore shields for player 1
0875: C3 14 08        JP      $0814               ; Continue in game loop
*/
  
  a = refAlienDXr;
  b = a;
  hl = refAlienCr;
  swap(de,hl);
  ^goto GetAlRefPtr;
  
/*
0878: 3A 08 20        LD      A,(refAlienDXr)     ; Alien deltaY
087B: 47              LD      B,A                 ; Hold it
087C: 2A 09 20        LD      HL,(refAlienYr)     ; Alien coordinates
087F: EB              EX      DE,HL               ; Coordinates to DE
0880: C3 86 08        JP      GetAlRefPtr         ; HL is 21FC or 22FC and out
*/
  nop();
  nop();
  nop();
/*  
0883: 00 00 00                                    ; ** Why?
*/
  
}

in rom @ 0x886 {
  func GetAlRefPtr() {
    a = playerDataMSB;
    h = a;
    l = 0xfc;
  }
  /*; Get pointer to player's alien ref coordiantes
0886: 3A 67 20        LD      A,(playerDataMSB)   ; Player data MSB (21 or 22)
0889: 67              LD      H,A                 ; To H
088A: 2E FC           LD      L,$FC               ; 21FC or 22FC ... alien coordinates
088C: C9              RET     
*/
}
in rom @ 0x88D {
/*
; Print "PLAY PLAYER <n>" and blink score for 2 seconds.
*/
  PromptPlayer:
  hl = 0x2B11;
  de = 0x1B70;
  c = 0xe;
  PrintMessage();
  a = playerDataMSB;
  const data_89b : u8 = 0xf; // RRCA
  a = 0x1c;
  hl = 0x3711;
  const data_8a1 : [u8;3] = [0xd4, 0xff, 0x08]; // CALL    NC,DrawChar
  a = 0xb0;
  isrDelay = a;
/*
088D: 21 11 2B        LD      HL,$2B11            ; Screen coordinates
0890: 11 70 1B        LD      DE,$1B70            ; Message "PLAY PLAYER<1>"
0893: 0E 0E           LD      C,$0E               ; 14 bytes in message
0895: CD F3 08        CALL    PrintMessage        ; Print the message
0898: 3A 67 20        LD      A,(playerDataMSB)   ; Get the player number
089B: 0F              RRCA                        ; C will be set for player 1
089C: 3E 1C           LD      A,$1C               ; The "2" character
089E: 21 11 37        LD      HL,$3711            ; Replace the "<1>" with "<2">
08A1: D4 FF 08        CALL    NC,DrawChar         ; If player 2 ... change the message
08A4: 3E B0           LD      A,$B0               ; Delay of 176 (roughly 2 seconds)
08A6: 32 C0 20        LD      (isrDelay),A        ; Set the ISR delay value
*/
  ^do {
    a = isrDelay;
    a = a & a;
    return if zero;
    a = a & 0x4;
    ^if zero {
      (0x9Ca as func)();
      DrawScore();
      ^goto (0x8A9 as func);
    }
    b = 0x20;
    hl = 0x271C;
    a = playerDataMSB;
    const data_8c4 : u8 = 0xf; // RRCA
    ^if !carry {
      hl = 0x391c;
    }
    ClearSmallSprite();
  } while true;
/*
08A9: 3A C0 20        LD      A,(isrDelay)        ; Get the ISR delay value
08AC: A7              AND     A                   ; Has the 2 second delay expired?
08AD: C8              RET     Z                   ; Yes ... done
08AE: E6 04           AND     $04                 ; Every 4 ISRs ...
08B0: C2 BC 08        JP      NZ,$08BC            ; ... flash the player's score
08B3: CD CA 09        CALL    $09CA               ; Get the score descriptor for the active player
08B6: CD 31 19        CALL    DrawScore           ; Draw the score
08B9: C3 A9 08        JP      $08A9               ; Back to the top of the wait loop
;
08BC: 06 20           LD      B,$20               ; 32 rows (4 characters * 8 bytes each)
08BE: 21 1C 27        LD      HL,$271C            ; Player-1 score on the screen
08C1: 3A 67 20        LD      A,(playerDataMSB)   ; Get the player number
08C4: 0F              RRCA                        ; C will be set for player 1
08C5: DA CB 08        JP      C,$08CB             ; We have the right score coordinates
08C8: 21 1C 39        LD      HL,$391C            ; Use coordinates for player-2's score
08CB: CD CB 14        CALL    ClearSmallSprite    ; Clear a one byte sprite at HL
08CE: C3 A9 08        JP      $08A9               ; Back to the top of the wait loop
  */
  
}
in rom @ 0x8D1 {
//; Get number of ships from DIP settings

  GetShipsPerCred:
  a = io_read(io.INP2);
  a = a & 0x3;
  a = a + 3;
  return;
  /*
08D1: DB 02           IN      A,(INP2)            ; DIP settings
08D3: E6 03           AND     $03                 ; Get number of ships
08D5: C6 03           ADD     A,$03               ; From 3-6
08D7: C9              RET                         ; Out
  */
}
  
in rom @ 0x8D8 {
/*
; With less than 9 aliens on the screen the alien shots get a tad bit faster. Probably
; because the advancing rack can catch them.
;*/
  func SpeedShots() {
    a = numAliens;
    cmp(a,0x09);
    return if !carry;
    a = 0xfb;
    alienShotDelta = a;
/*
08D8: 3A 82 20        LD      A,(numAliens)       ; Number of aliens on screen
08DB: FE 09           CP      $09                 ; More than 8?
08DD: D0              RET     NC                  ; Yes ... leave shot speed alone
08DE: 3E FB           LD      A,$FB               ; Normally FF (-4) ... now FB (-5)
08E0: 32 7E 20        LD      (alienShotDelta),A  ; Speed up alien shots
08E3: C9              RET                         ; Done
*/
  }
  a = twoPlayers;
  a = a & a;
  return if !zero;
  hl = 0x391C;
  b = 0x20;
  ^goto ClearSmallSprite;
  /*
08E4: 3A CE 20        LD      A,(twoPlayers)      ; Number of players
08E7: A7              AND     A                   ; Skip if ...
08E8: C0              RET     NZ                  ; ... two player
08E9: 21 1C 39        LD      HL,$391C            ; Player 2's score
08EC: 06 20           LD      B,$20               ; 32 rows is 4 digits * 8 rows each
08EE: C3 CB 14        JP      ClearSmallSprite    ; Clear a one byte sprite (32 rows long) at HL
*/
  c = 3;
/*
08F1: 0E 03           LD      C,$03               ; Length of saucer-score message ... fall into print
*/
  
}
in rom @ 0x8F3 {
/*
; Print a message on the screen
; HL = coordinates
; DE = message buffer
; C = length
*/
  func PrintMessage() {
    ^do {
      a = *(de as *u8);
      push (de);
      DrawChar();
      de = pop();
      de++;
      c--;
    } while !zero;
  }
  
/*
08F3: 1A              LD      A,(DE)              ; Get character
08F4: D5              PUSH    DE                  ; Preserve
08F5: CD FF 08        CALL    DrawChar            ; Print character
08F8: D1              POP     DE                  ; Restore
08F9: 13              INC     DE                  ; Next character
08FA: 0D              DEC     C                   ; All done?
08FB: C2 F3 08        JP      NZ,PrintMessage     ; Print all of message
08FE: C9              RET                         ; Out
  */
  
}
  
in rom @ 0x8FF {
/*
;=============================================================
; Get pointer to 8 byte sprite number in A and
; draw sprite on screen at HL
*/
  DrawChar:
  de = 0x1E00;
  push(hl);
  h = 0;
  l = a;
  hl += hl;
  hl += hl;
  hl += hl;
  hl += de;
  swap(de,hl);
  hl = pop();
  b = 8;
  io_write(io.WATCHDOG,a);
  ^goto DrawSimpSprite;  
/*
08FF: 11 00 1E        LD      DE,$1E00            ; Character set
0902: E5              PUSH    HL                  ; Preserve
0903: 26 00           LD      H,$00               ; MSB=0
0905: 6F              LD      L,A                 ; Character number to L
0906: 29              ADD     HL,HL               ; HL = HL *2
0907: 29              ADD     HL,HL               ; *4
0908: 29              ADD     HL,HL               ; *8 (8 bytes each)
0909: 19              ADD     HL,DE               ; Get pointer to sprite
090A: EB              EX      DE,HL               ; Now into DE
090B: E1              POP     HL                  ; Restore HL
090C: 06 08           LD      B,$08               ; 8 bytes each
090E: D3 06           OUT     (WATCHDOG),A        ; Feed watchdog
0910: C3 39 14        JP      DrawSimpSprite      ; To screen
  */
  
}
  
  
in rom @ 0x913 {
  func TimeToSaucer() {
    a = refAlienYr;
    cmp(a,0x78);
    return if !carry;
    hl = tillSaucer;
    a = l;
    a = a | h;
    ^if zero {
      hl = 0x600;
      a = 1;
      saucerStart = a;
    }
    hl--;
    tillSaucer = hl;
  /*
0913: 3A 09 20        LD      A,(refAlienYr)      ; Reference alien's X coordinate
0916: FE 78           CP      $78                 ; Don't process saucer timer ... ($78 is 1st rack Yr)
0918: D0              RET     NC                  ; ... unless aliens are closer to bottom
0919: 2A 91 20        LD      HL,(tillSaucerLSB)  ; Time to saucer
091C: 7D              LD      A,L                 ; Is it time ...
091D: B4              OR      H                   ; ... for a saucer
091E: C2 29 09        JP      NZ,$0929            ; No ... skip flagging
0921: 21 00 06        LD      HL,$0600            ; Reset timer to 600 game loops
0924: 3E 01           LD      A,$01               ; Flag a ...
0926: 32 83 20        LD      (saucerStart),A     ; ... saucer sequence
0929: 2B              DEC     HL                  ; Decrement the ...
092A: 22 91 20        LD      (tillSaucerLSB),HL  ; ... time-to-saucer
092D: C9              RET    
*/
  }
}
in rom @ 0x92E {
/*
;=============================================================
; Get number of ships for acive player
*/
  GetPlayerDataPtr();
  l = 0xff;
  a = *(hl as *u8);
  return;
/*
092E: CD 11 16        CALL    GetPlayerDataPtr    ; HL points to player data
0931: 2E FF           LD      L,$FF               ; Last byte = numbe of ships
0933: 7E              LD      A,(HL)              ; Get number of ships
0934: C9              RET                         ; Done
*/
}
  
in rom @ 0x935 {
/*;=============================================================
; Award extra ship if score has reached ceiling
*/
  CurPlyAlive();
  hl--;
  hl--;
  a = *(hl as *u8);
  a = a & a;
  return if zero;
  b = 0x15;
  a = io_read(io.INP2);
  a = a & 8;
  ^if !zero {
    b = 0x10;
  }
  (0x9ca as func)();
  hl++;
  a = *(hl as *u8);
  cmp(a,b);
  return if carry;
  (0x92E as func)();
  ++*(hl as *u8);
  a = *(hl as *u8);
  push (af);
  hl = 0x2501;
  ^do {
    h++;
    h++;
    a--;
  } while !zero;
  b = 0x10;
  de = 0x1C60;
  DrawSimpSprite();
  af = pop();
  a++;
  (0x1A8B as func)();
  CurPlyAlive();
  hl--;
  hl--;
  *(hl as *u8) = 0;
  a = 0xff;
  extraHold = a;
  b = 0x10;
  ^ goto SoundBits3On;
  /*
0935: CD 10 19        CALL    CurPlyAlive         ; Get descriptor of sorts
0938: 2B              DEC     HL                  ; Back up ...
0939: 2B              DEC     HL                  ; ... two bytes
093A: 7E              LD      A,(HL)              ; Has extra ship ...
093B: A7              AND     A                   ; already been awarded?
093C: C8              RET     Z                   ; Yes ... ignore
093D: 06 15           LD      B,$15               ; Default 1500
093F: DB 02           IN      A,(INP2)            ; Read DIP settings
0941: E6 08           AND     $08                 ; Extra ship at 1000 or 1500
0943: CA 48 09        JP      Z,$0948             ; 0=1500
0946: 06 10           LD      B,$10               ; Awarded at 1000
0948: CD CA 09        CALL    $09CA               ; Get score descriptor for active player
094B: 23              INC     HL                  ; MSB of score ...
094C: 7E              LD      A,(HL)              ; ... to accumulator
094D: B8              CP      B                   ; Time for an extra ship?
094E: D8              RET     C                   ; No ... out
094F: CD 2E 09        CALL    $092E               ; Get pointer to number of ships
0952: 34              INC     (HL)                ; Bump number of ships
0953: 7E              LD      A,(HL)              ; Get the new total
0954: F5              PUSH    AF                  ; Hang onto it for a bit
0955: 21 01 25        LD      HL,$2501            ; Screen coords for ship hold
0958: 24              INC     H                   ; Bump to ...
0959: 24              INC     H                   ; ... next
095A: 3D              DEC     A                   ; ... spot
095B: C2 58 09        JP      NZ,$0958            ; Find spot for new ship
095E: 06 10           LD      B,$10               ; 16 byte sprite
0960: 11 60 1C        LD      DE,$1C60            ; Player sprite
0963: CD 39 14        CALL    DrawSimpSprite      ; Draw the sprite
0966: F1              POP     AF                  ; Restore the count
0967: 3C              INC     A                   ; +1
0968: CD 8B 1A        CALL    $1A8B               ; Print the number of ships
096B: CD 10 19        CALL    CurPlyAlive         ; Get descriptor for active player of some sort
096E: 2B              DEC     HL                  ; Back up ...
096F: 2B              DEC     HL                  ; ... two bytes
0970: 36 00           LD      (HL),$00            ; Flag extra ship has been awarded
0972: 3E FF           LD      A,$FF               ; Set timer ...
0974: 32 99 20        LD      (extraHold),A       ; ... for extra-ship sound
0977: 06 10           LD      B,$10               ; Make sound ...
0979: C3 FA 18        JP      SoundBits3On        ; ... for extra man
*/
}

in rom @ 0x97C {
  func AlienScoreValue() {
    hl = 0x1DA0;
    cmp(a,2);
    return if carry;
    hl++;
    cmp(a,4);
    return if carry;
    hl++;
  }
  /*
097C: 21 A0 1D        LD      HL,$1DA0            ; Table for scores for hitting alien
097F: FE 02           CP      $02                 ; 0 or 1 (lower two rows) ...
0981: D8              RET     C                   ; ... return HL points to value 10
0982: 23              INC     HL                  ; next value
0983: FE 04           CP      $04                 ; 2 or 3 (middle two rows) ...
0985: D8              RET     C                   ; ... return HL points to value 20
0986: 23              INC     HL                  ; Top row ...
0987: C9              RET                         ; ... return HL points to value 30
  */
}
  
in rom @ 0x988 {
/*
; Adjust the score for the active player. 20F1 is 1 if there is a new value to add.
; The adjustment is in 20F2,20F3. Then print the score.
*/
  AdjustScore:
  (0x9CA as func)();
  a = adjustScore;
  a = a & a;
  return if zero;
  a = a ^ a;
  adjustScore = a;
  push(hl);
  hl = scoreDelta;
  swap(de,hl);
  hl = pop();
  a = *(hl as *u8);
  a += e;
  decimal_adjust();
  *(hl as *u8) = a;
  e = a;
  hl++;
  a = *(hl as *u8);
  a = a +# d;
  decimal_adjust();
  *(hl as *u8) = a;
  d = a;
  hl++;
  a = *(hl as *u8);
  hl++;
  h = *(hl as *u8);
  l = a;
  ^goto Print4Digits;
/*0988: CD CA 09        CALL    $09CA               ; Get score structure for active player
098B: 3A F1 20        LD      A,(adjustScore)     ; Does the score ...
098E: A7              AND     A                   ; ... need increasing?
098F: C8              RET     Z                   ; No ... done
0990: AF              XOR     A                   ; Mark score ...
0991: 32 F1 20        LD      (adjustScore),A     ; ... as adjusted
0994: E5              PUSH    HL                  ; Hold the pointer to the structure
0995: 2A F2 20        LD      HL,(scoreDeltaLSB)  ; Get requested adjustment
0998: EB              EX      DE,HL               ; Adjustment to DE
0999: E1              POP     HL                  ; Get back pointer to structure
099A: 7E              LD      A,(HL)              ; Add adjustment ...
099B: 83              ADD     A,E                 ; ... first byte
099C: 27              DAA                         ; Adjust it for BCD
099D: 77              LD      (HL),A              ; Store new LSB
099E: 5F              LD      E,A                 ; Add adjustment ...
099F: 23              INC     HL                  ; ... to ...
09A0: 7E              LD      A,(HL)              ; ... second ...
09A1: 8A              ADC     A,D                 ; ... byte
09A2: 27              DAA                         ; Adjust for BCD (cary gets dropped)
09A3: 77              LD      (HL),A              ; Store second byte
09A4: 57              LD      D,A                 ; Second byte to D (first byte still in E)
09A5: 23              INC     HL                  ; Load ...
09A6: 7E              LD      A,(HL)              ; ... the ...
09A7: 23              INC     HL                  ; ... screen ...
09A8: 66              LD      H,(HL)              ; ... coordinates ...
09A9: 6F              LD      L,A                 ; ... to HL
09AA: C3 AD 09        JP      Print4Digits        ; ** Usually a good idea, but wasted here
  */
  
}

in rom @ 0x9AD {
/*
; Print 4 digits in DE
*/
  Print4Digits:
  a = d;
  DrawHexByte();
  a = e;
  /*
09AD: 7A              LD      A,D                 ; Get first 2 digits of BCD or hex
09AE: CD B2 09        CALL    DrawHexByte         ; Print them
09B1: 7B              LD      A,E                 ; Get second 2 digits of BCD or hex (fall into print)
*/
/*
; Display 2 digits in A to screen at HL
*/
DrawHexByte:
  push(de);
  push(af);
  const data09b4 : [u8] = [0xf,0xf,0xf,0xf];
  a = a & 0x0f;
  (0x9C5 as func)();
  af = pop();
  a = a & 0x0f;
  (0x9C5 as func)();
  de = pop();
  return;
  /*
09B2: D5              PUSH    DE                  ; Preserve
09B3: F5              PUSH    AF                  ; Save for later
09B4: 0F              RRCA                        ; Get ...
09B5: 0F              RRCA                        ; ...
09B6: 0F              RRCA                        ; ...
09B7: 0F              RRCA                        ; ... left digit
09B8: E6 0F           AND     $0F                 ; Mask out lower digit's bits
09BA: CD C5 09        CALL    $09C5               ; To screen at HL
09BD: F1              POP     AF                  ; Restore digit
09BE: E6 0F           AND     $0F                 ; Mask out upper digit
09C0: CD C5 09        CALL    $09C5               ; To screen
09C3: D1              POP     DE                  ; Restore
09C4: C9              RET                         ; Done
*/

  a = a + 0x1A;
  ^goto DrawChar;
/*
09C5: C6 1A           ADD     A,$1A               ; Bump to number characters
09C7: C3 FF 08        JP      DrawChar            ; Continue ...
  */
  
}
  
in rom @ 0x9CA {
//; Get score descriptor for active player
  a = playerDataMSB;
  const data_9cd : u8 = 0xf; // RRCA
  hl = 0x20F8;
  return if carry;
  hl = 0x20FC;
  return;
  
/*
09CA: 3A 67 20        LD      A,(playerDataMSB)   ; Get active player
09CD: 0F              RRCA                        ; Test for player
09CE: 21 F8 20        LD      HL,$20F8            ; Player 1 score descriptor
09D1: D8              RET     C                   ; Keep it if player 1 is active
09D2: 21 FC 20        LD      HL,$20FC            ; Else get player 2 descriptor
09D5: C9              RET                         ; Out
*/  
  
}

in rom @ 0x9D6 {
// Clear center window of screen

  func ClearPlayField() {
    hl = 0x2402;
    ^do {
      *(hl as *u8) = 0;
      hl++;
      a = l;
      a = a & 0x1f;
      cmp(a,0x1c);
      ^if !carry {
        de = 6;
        hl+=de;
      }
      a = h;
      cmp(a,0x40);
    } while carry;
    
/*
09D6: 21 02 24        LD      HL,$2402            ; Thrid from left, top of screen
09D9: 36 00           LD      (HL),$00            ; Clear screen byte
09DB: 23              INC     HL                  ; Next in row
09DC: 7D              LD      A,L                 ; Get X ...
09DD: E6 1F           AND     $1F                 ; ... coordinate
09DF: FE 1C           CP      $1C                 ; Edge minus a buffer?
09E1: DA E8 09        JP      C,$09E8             ; No ... keep going
09E4: 11 06 00        LD      DE,$0006            ; Else ... bump to
09E7: 19              ADD     HL,DE               ; ... next edge + buffer
09E8: 7C              LD      A,H                 ; Get Y coordinate
09E9: FE 40           CP      $40                 ; Reached bottom?
09EB: DA D9 09        JP      C,$09D9             ; No ... keep going
09EE: C9              RET                         ; Done
  */
  }
}

in rom @ 0x9EF {
  (0xA3C as func)();
  a = a ^ a;
  suspendPlay = a;
  ClearPlayField();
  a = playerDataMSB;
  push(af);
  CopyRAMMirror();
  af = pop();
  playerDataMSB = a;
  a = playerDataMSB;
  h = a;
  push(hl);
  l = 0xfe;
  a = *(hl as *u8);
  a = a & 7;
  a++;
  *(hl as *u8) = a;
  hl = 0x1DA2;
  ^do {
    hl++;
    a--;
  } while !zero;
  
  a = *(hl as *u8);
  hl = pop();
  l = 0xfc;
  *(hl as *u8) = a;
  hl++;
  *(hl as *u8) = 0x38;
  a = h;
  const data_a21 : u8 = 0xf;
  ^if !carry {
    a = 0x21;
    soundPort5 = a;
    DrawShieldPl2();
    InitAliensP2();
    ^goto (0x804 as func);
  }
/*
09EF: CD 3C 0A        CALL    $0A3C               ; 
09F2: AF              XOR     A                   ; Suspend ...
09F3: 32 E9 20        LD      (suspendPlay),A     ; ... ISR game tasks
09F6: CD D6 09        CALL    ClearPlayField      ; Clear playfield
09F9: 3A 67 20        LD      A,(playerDataMSB)   ; Hold current player number ...
09FC: F5              PUSH    AF                  ; ... on stack
09FD: CD E4 01        CALL    CopyRAMMirror       ; Block copy RAM mirror from ROM
0A00: F1              POP     AF                  ; Restore ...
0A01: 32 67 20        LD      (playerDataMSB),A   ; ... current player number
0A04: 3A 67 20        LD      A,(playerDataMSB)   ; ** Why load this again? Nobody ever jumps to 0A04?
0A07: 67              LD      H,A                 ; To H
0A08: E5              PUSH    HL                  ; Hold player-data pointer
0A09: 2E FE           LD      L,$FE               ; 2xFE ... rack count
0A0B: 7E              LD      A,(HL)              ; Get the number of racks the player has beaten
0A0C: E6 07           AND     $07                 ; 0-7
0A0E: 3C              INC     A                   ; Now 1-8
0A0F: 77              LD      (HL),A              ; Update count since player just beat a rack
0A10: 21 A2 1D        LD      HL,$1DA2            ; Starting coordinate of alien table
0A13: 23              INC     HL                  ; Find the ...
0A14: 3D              DEC     A                   ; ... right entry ...
0A15: C2 13 0A        JP      NZ,$0A13            ; ... in the table
0A18: 7E              LD      A,(HL)              ; Get the starting Y coordiante
0A19: E1              POP     HL                  ; Restore player's pointer
0A1A: 2E FC           LD      L,$FC               ; 2xFC ...
0A1C: 77              LD      (HL),A              ; Set rack's starting Y coordinate
0A1D: 23              INC     HL                  ; Point to X
0A1E: 36 38           LD      (HL),$38            ; Set rack's starting X coordinate to 38
0A20: 7C              LD      A,H                 ; Player ...
0A21: 0F              RRCA                        ; ... number to carry  
0A22: DA 33 0A        JP      C,$0A33             ; 2nd player stuff
0A25: 3E 21           LD      A,$21               ; Start fleet with ...
0A27: 32 98 20        LD      (soundPort5),A      ; ... first sound
0A2A: CD F5 01        CALL    DrawShieldPl2       ; Draw shields for player 2
0A2D: CD 04 19        CALL    InitAliensP2        ; Initalize aliens for player 2
0A30: C3 04 08        JP      $0804               ; Continue at top of game loop
;
*/
  DrawShieldPl1();
  InitAliens();
  ^goto (0x804 as func);
  /*
0A33: CD EF 01        CALL    DrawShieldPl1       ; Draw shields for player 1
0A36: CD C0 01        CALL    InitAliens          ; Initialize aliens for player 1
0A39: C3 04 08        JP      $0804               ; Continue at top of game loop
;*/
}
  
in rom @ 0xA3C {
  (0xA59 as func)();
  ^if zero {
    a = 0x30;
    isrDelay = a;
    ^do {
      a = isrDelay;
      a = a & a;
      return if zero;
      (0xA59 as func)();
    } while zero;
  }
  ^do {
    (0xA59 as func)();
  } while !zero;
  return;
/*
0A3C: CD 59 0A        CALL    $0A59               ; Check player collision
0A3F: C2 52 0A        JP      NZ,$0A52            ; Player is not alive ... skip delay
0A42: 3E 30           LD      A,$30               ; Half second delay
0A44: 32 C0 20        LD      (isrDelay),A        ; Set ISR timer
0A47: 3A C0 20        LD      A,(isrDelay)        ; Has timer expired?
0A4A: A7              AND     A                   ; Check exipre
0A4B: C8              RET     Z                   ; Out if done
0A4C: CD 59 0A        CALL    $0A59               ; Check player collision
0A4F: CA 47 0A        JP      Z,$0A47             ; No collision ... wait on timer
0A52: CD 59 0A        CALL    $0A59               ; Wait for ...
0A55: C2 52 0A        JP      NZ,$0A52            ; ... collision to end
0A58: C9              RET                         ; Done
*/
}

in rom @ 0xA59 {
//; Check to see if player is hit
  a = playerAlive;
  cmp(a,0xff);
  return;
/*
0A59: 3A 15 20        LD      A,(playerAlive)     ; Active player hit flag
0A5C: FE FF           CP      $FF                 ; All FFs means player is OK
0A5E: C9              RET                         ; Out
*/  
}
  
in rom @ 0xA5F {
// Start the hit-alien sound and flag the adjustment for the score.
// B contains the row, which determines the score value.

  func ScoreForAlien() {
    a = gameMode;
    a = a & a;
    ^if !zero {
      c = b;
      b = 8;
      SoundBits3On();
      b = c;
      a = b;
      AlienScoreValue();
      a = *(hl as *u8);
      hl = 0x20F3;
      *(hl as *u8) = 0;
      hl--;
      *(hl as *u8) = a;
      hl--;
      *(hl as *u8) = 1;
    }
    hl = 0x2062;
  /*
0A5F: 3A EF 20        LD      A,(gameMode)        ; Are we in ...
0A62: A7              AND     A                   ; ... game mode?
0A63: CA 7C 0A        JP      Z,$0A7C             ; No ... skip scoring in demo
0A66: 48              LD      C,B                 ; Hold row number
0A67: 06 08           LD      B,$08               ; Alien hit sound
0A69: CD FA 18        CALL    SoundBits3On        ; Enable sound
0A6C: 41              LD      B,C                 ; Restore row number
0A6D: 78              LD      A,B                 ; Into A
0A6E: CD 7C 09        CALL    AlienScoreValue     ; Look up the score for the alien
0A71: 7E              LD      A,(HL)              ; Get the score value
0A72: 21 F3 20        LD      HL,$20F3            ; Pointer to score delta
0A75: 36 00           LD      (HL),$00            ; Upper byte of score delta is "00"
0A77: 2B              DEC     HL                  ; Point to score delta LSB
0A78: 77              LD      (HL),A              ; Set score for hitting alien
0A79: 2B              DEC     HL                  ; Point to adjust-score-flag
0A7A: 36 01           LD      (HL),$01            ; The score will get changed elsewhere
0A7C: 21 62 20        LD      HL,$2062            ; Return exploding-alien descriptor
0A7F: C9              RET                         ; Out
  */
    }
}

in rom @ 0xA80 {
//; Start the ISR moving the sprite. Return when done.
  func Animate() {
    a = 2;
    isrSplashTask = a;
    ^do {
      io_write(io.WATCHDOG,a);
      a = splashReached;
      a = a & a;
    } while zero;
    a = a ^ a;
    isrSplashTask = a;
  /*
0A80: 3E 02           LD      A,$02               ; Start simple linear ...
0A82: 32 C1 20        LD      (isrSplashTask),A   ; ... sprite animation (splash)
0A85: D3 06           OUT     (WATCHDOG),A        ; Feed watchdog
0A87: 3A CB 20        LD      A,(splashReached)   ; Has the ...
0A8A: A7              AND     A                   ; ... sprite reached target?
0A8B: CA 85 0A        JP      Z,$0A85             ; No ... wait
0A8E: AF              XOR     A                   ; Stop ...
0A8F: 32 C1 20        LD      (isrSplashTask),A   ; ... ISR animation
0A92: C9              RET                         ; Done
  */
}
}
  
  
in rom @ 0xA93 {
/*
; Print message from DE to screen at HL (length in C) with a
; delay between letters.
*/
  PrintMessageDel:
  ^do {
    push(de);
    a = *(de as *u8);
    DrawChar();
    de = pop();
    a = 7;
    isrDelay = a;
    ^do {
      a = isrDelay;
      a--;
    } while !zero;
    de++;
    c--;  
  } while !zero;
  return;
/*
0A93: D5              PUSH    DE                  ; Preserve
0A94: 1A              LD      A,(DE)              ; Get character
0A95: CD FF 08        CALL    DrawChar            ; Draw character on screen
0A98: D1              POP     DE                  ; Preserve
0A99: 3E 07           LD      A,$07               ; Delay between letters
0A9B: 32 C0 20        LD      (isrDelay),A        ; Set counter
0A9E: 3A C0 20        LD      A,(isrDelay)        ; Get counter
0AA1: 3D              DEC     A                   ; Is it 1?
0AA2: C2 9E 0A        JP      NZ,$0A9E            ; No ... wait on it
0AA5: 13              INC     DE                  ; Next in message
0AA6: 0D              DEC     C                   ; All done?
0AA7: C2 93 0A        JP      NZ,PrintMessageDel  ; No ... do all
0AAA: C9              RET                         ; Out
  */
}
  
in rom @ 0xAAB {
SplashSquiggly:
  hl = 0x2050;
  ^goto (0x24B as func);
/*
0AAB: 21 50 20        LD      HL,$2050            ; Pointer to game-object 4 timer
0AAE: C3 4B 02        JP      $024B               ; Process squiggly-shot in demo mode
*/  
}
in rom @ 0xAB1 {
// Delay 64 interrupts

  OneSecDelay:
  a = 0x40;
  ^goto WaitOnDelay;
  /*
0AB1: 3E 40           LD      A,$40               ; Delay of 64 (tad over 1 sec)
0AB3: C3 D7 0A        JP      WaitOnDelay         ; Do delay
  */
  
}
  
in rom @ 0xAB6 {
// Delay 128 interrupts

  TwoSecDelay:
  a = 0x80;
  ^goto WaitOnDelay;
/*
0AB6: 3E 80           LD      A,$80               ; Delay of 80 (tad over 2 sec)
0AB8: C3 D7 0A        JP      WaitOnDelay         ; Do delay
*/
}

in rom @ 0xABB {
SplashDemo:
  hl = pop();
  ^goto (0x72 as func);
  /*
0ABB: E1              POP     HL                  ; Drop the call to ABF and ...
0ABC: C3 72 00        JP      $0072               ; ... do a demo game loop without sound
  */
}
  
  
in rom @ 0xABF {
/*; Different types of splash tasks managed by ISR in splash screens. The ISR
; calls this if in splash-mode. These may have been bit flags to allow all 3
; at the same time. Maybe it is just easier to do a switch with a rotate-to-carry.
;*/

  ISRSplTasks:
  a = isrSplashTask;
  const data_ac2 : u8 = 0xf;
  ^goto SplashDemo if carry;
  const data_ac6 : u8 = 0xf;
  ^goto SplashSprite if carry;
  const data_acA : u8 = 0xf;  
  ^goto SplashSquiggly if carry;
  return;
  /*
0ABF: 3A C1 20        LD      A,(isrSplashTask)   ; Get the ISR task number
0AC2: 0F              RRCA                        ; In demo play mode?
0AC3: DA BB 0A        JP      C,SplashDemo        ; 1: Yes ... go do game play (without sound)
0AC6: 0F              RRCA                        ; Moving little alien from point A to B?
0AC7: DA 68 18        JP      C,SplashSprite      ; 2: Yes ... go move little alien from point A to B
0ACA: 0F              RRCA                        ; Shooting extra "C" with squiggly shot?
0ACB: DA AB 0A        JP      C,SplashSquiggly    ; 4: Yes ... go shoot extra "C" in splash
0ACE: C9              RET                         ; No task to do
*/
}
  
in rom @ 0xACF {
/*
; Message to center of screen.
; Only used in one place for "SPACE  INVADERS"
*/
  
  hl = 0x2B14;
  c = 0xf;
  ^goto PrintMessageDel;
/*
0ACF: 21 14 2B        LD      HL,$2B14            ; Near center of screen
0AD2: 0E 0F           LD      C,$0F               ; 15 bytes in message
0AD4: C3 93 0A        JP      PrintMessageDel     ; Print and out
*/
  
}

in rom @ 0xAD7 {
//  Wait on ISR counter to reach 0

  func WaitOnDelay() {
    isrDelay = a;
    ^do {
      a = isrDelay;
      a = a & a;
    } while !zero;
/*
0AD7: 32 C0 20        LD      (isrDelay),A        ; Delay counter
0ADA: 3A C0 20        LD      A,(isrDelay)        ; Get current delay
0ADD: A7              AND     A                   ; Zero yet?
0ADE: C2 DA 0A        JP      NZ,$0ADA            ; No ... wait on it
0AE1: C9              RET                         ; Out
*/
  }
}

in rom @ 0xAE2 {
// Init the splash-animation block

  IniSplashAni:
  hl = 0x20C2;
  b = 0xc;
  ^goto BlockCopy;
/*
0AE2: 21 C2 20        LD      HL,$20C2            ; The splash-animation descriptor
0AE5: 06 0C           LD      B,$0C               ; C bytes
0AE7: C3 32 1A        JP      BlockCopy           ; Block copy DE to descriptor
*/  
  
}
  
in rom @ 0xAEA {
/*
;=============================================================
; After initialization ... splash screens
*/
  a = a ^ a;
  io_write(io.SOUND1, a);
  io_write(io.SOUND2, a);
  (0x1982 as func)();
  interrupt = true;
  OneSecDelay();
  a = splashAnimate;
  a = a & a;
  hl = 0x3017;
  c = 4;
  ^goto (0xbe8 as func) if !zero;
  de = 0x1CFA;
  PrintMessageDel();
  de = 0x1DAF;
  (0xACF as func)();
  OneSecDelay();
  DrawAdvTable();
  TwoSecDelay();
  a = splashAnimate;
  a = a & a;
  ^goto (0xB4A as func) if !zero;
/*
0AEA: AF              XOR     A                   ; Make a 0
0AEB: D3 03           OUT     (SOUND1),A          ; Turn off sound
0AED: D3 05           OUT     (SOUND2),A          ; Turn off sound
0AEF: CD 82 19        CALL    $1982               ; Turn off ISR splash-task
0AF2: FB              EI                          ; Enable interrupts (using them for delays)
0AF3: CD B1 0A        CALL    OneSecDelay         ; One second delay
0AF6: 3A EC 20        LD      A,(splashAnimate)   ; Splash screen type
0AF9: A7              AND     A                   ; Set flags based on type
0AFA: 21 17 30        LD      HL,$3017            ; Screen coordinates (middle near top)
0AFD: 0E 04           LD      C,$04               ; 4 characters in "PLAY"
0AFF: C2 E8 0B        JP      NZ,$0BE8            ; Not 0 ... do "normal" PLAY
0B02: 11 FA 1C        LD      DE,$1CFA            ; The "PLAy" with an upside down 'Y'
0B05: CD 93 0A        CALL    PrintMessageDel     ; Print the "PLAy"
0B08: 11 AF 1D        LD      DE,$1DAF            ; "SPACE  INVADERS" message
0B0B: CD CF 0A        CALL    $0ACF               ; Print to middle-ish of screen
0B0E: CD B1 0A        CALL    OneSecDelay         ; One second delay
0B11: CD 15 18        CALL    DrawAdvTable        ; Draw "SCORE ADVANCE TABLE" with print delay
0B14: CD B6 0A        CALL    TwoSecDelay         ; Two second delay
0B17: 3A EC 20        LD      A,(splashAnimate)   ; Do splash ...
0B1A: A7              AND     A                   ; ... animations?
0B1B: C2 4A 0B        JP      NZ,$0B4A            ; Not 0 ... no animations
*/
}

in rom @ 0xB1E {
// Animate small alien replacing upside-down Y with correct Y
  de = 0x1A95;
  IniSplashAni();
  Animate();
  de = 0x1BB0;
  IniSplashAni();
  Animate();
  OneSecDelay();
  de = 0x1FC9;
  IniSplashAni();
  Animate();
  OneSecDelay();
  hl = 0x33B7;
  b = 0xa;
  ClearSmallSprite();
  TwoSecDelay();
/*
0B1E: 11 95 1A        LD      DE,$1A95            ; Animate sprite from Y=FE to Y=9E step -1
0B21: CD E2 0A        CALL    IniSplashAni        ; Copy to splash-animate structure
0B24: CD 80 0A        CALL    Animate             ; Wait for ISR to move sprite (small alien)
0B27: 11 B0 1B        LD      DE,$1BB0            ; Animate sprite from Y=98 to Y=FF step 1
0B2A: CD E2 0A        CALL    IniSplashAni        ; Copy to splash-animate structure
0B2D: CD 80 0A        CALL    Animate             ; Wait for ISR to move sprite (alien pulling upside down Y)
0B30: CD B1 0A        CALL    OneSecDelay         ; One second delay
0B33: 11 C9 1F        LD      DE,$1FC9            ; Animate sprite from Y=FF to Y=97 step 1
0B36: CD E2 0A        CALL    IniSplashAni        ; Copy to splash-animate structure
0B39: CD 80 0A        CALL    Animate             ; Wait for ISR to move sprite (alien pushing Y)
0B3C: CD B1 0A        CALL    OneSecDelay         ; One second delay
0B3F: 21 B7 33        LD      HL,$33B7            ; Where the splash alien ends up
0B42: 06 0A           LD      B,$0A               ; 10 rows
0B44: CD CB 14        CALL    ClearSmallSprite    ; Clear a one byte sprite at HL
0B47: CD B6 0A        CALL    TwoSecDelay         ; Two second delay
*/ 
  
}
  
in rom @ 0xB4A {
//  ; Play demo
  ClearPlayField();
  a = p1.ShipsRem;
  a = a & a;
  ^if zero {
    GetShipsPerCred();
    p1.ShipsRem = a;
    RemoveShip();
  }
  /*
0B4A: CD D6 09        CALL    ClearPlayField      ; Clear playfield
0B4D: 3A FF 21        LD      A,(p1ShipsRem)      ; Number of ships for player-1
0B50: A7              AND     A                   ; If non zero ...
0B51: C2 5D 0B        JP      NZ,$0B5D            ; ... keep it (counts down between demos)
0B54: CD D1 08        CALL    GetShipsPerCred     ; Get number of ships from DIP settings
0B57: 32 FF 21        LD      (p1ShipsRem),A      ; Reset number of ships for player-1
0B5A: CD 7F 1A        CALL    RemoveShip          ; Remove a ship from stash and update indicators
*/
  CopyRAMMirror();
  InitAliens();
  DrawShieldPl1();
  RestoreShields1();
  a = 1;
  isrSplashTask = a;
  DrawBottomLine();
/*
0B5D: CD E4 01        CALL    CopyRAMMirror       ; Block copy ROM mirror to initialize RAM
0B60: CD C0 01        CALL    InitAliens          ; Initialize all player 1 aliens
0B63: CD EF 01        CALL    DrawShieldPl1       ; Draw shields for player 1 (to buffer)
0B66: CD 1A 02        CALL    RestoreShields1     ; Restore shields for player 1 (to screen)
0B69: 3E 01           LD      A,$01               ; ISR splash-task ...
0B6B: 32 C1 20        LD      (isrSplashTask),A   ; ... playing demo
0B6E: CD CF 01        CALL    DrawBottomLine      ; Draw playfield line
*/
  ^do {
    PlrFireOrDemo();
    (0xBF1 as func)();
    io_write(io.WATCHDOG,a);
    (0xA59 as func)();
  } while zero;
  a = a ^ a;
  plyrShotStatus = a;
  ^do {
    (0xA59 as func)();
  } while !zero;
/*
0B71: CD 18 16        CALL    PlrFireOrDemo       ; In demo ... process demo movement and always fire
0B74: CD F1 0B        CALL    $0BF1               ; Check player shot and aliens bumping edges of screen and hidden message
0B77: D3 06           OUT     (WATCHDOG),A        ; Feed watchdog
0B79: CD 59 0A        CALL    $0A59               ; Has demo player been hit?
0B7C: CA 71 0B        JP      Z,$0B71             ; No ... continue game
0B7F: AF              XOR     A                   ; Remove player shot ...
0B80: 32 25 20        LD      (plyrShotStatus),A  ; ... from activity
0B83: CD 59 0A        CALL    $0A59               ; Wait for demo player ...
0B86: C2 83 0B        JP      NZ,$0B83            ; ... to stop exploding
;
  */
}
  
in rom @ 0xB89 {
/*
; Credit information
*/
  a = a ^ a;
  isrSplashTask = a;
  OneSecDelay();
  (0x1988 as func)();
  c = 0xc;
  hl = 0x2C11;
  de = 0x1F90;
  PrintMessage();
  a = splashAnimate;
  cmp(a,0);
  ^if zero {
    hl = 0x3311;
    a = 2;
    DrawChar();
  }
  bc = 0x1F9C;
  ReadPriStruct();
  (0x184C as func)();
  a = io_read(io.INP2);
  const data_bb9 : u8 = 0x7; // RLCA
  ^if !carry {
    bc = 0x1FA0;
    (0x183A as func)();
  }
  TwoSecDelay();
  a = splashAnimate;
  cmp(a,0);
  ^if zero {
    de = 0x1FD5;
    IniSplashAni();
    Animate();
    (0x189E as func)();
  }
  hl = 0x20EC;
  a = *(hl as *u8);
  a++;
  a = a & 1;
  *(hl as *u8) = a;
  ClearPlayField();
  ^goto (0x18DF as func);
/*
0B89: AF              XOR     A                   ; Turn off ...
0B8A: 32 C1 20        LD      (isrSplashTask),A   ; ... splash animation
0B8D: CD B1 0A        CALL    OneSecDelay         ; One second delay
0B90: CD 88 19        CALL    $1988               ; ** Something else at one time? Jump straight to clear-play-field
0B93: 0E 0C           LD      C,$0C               ; Message size
0B95: 21 11 2C        LD      HL,$2C11            ; Screen coordinates
0B98: 11 90 1F        LD      DE,$1F90            ; "INSERT  COIN"
0B9B: CD F3 08        CALL    PrintMessage        ; Print message
0B9E: 3A EC 20        LD      A,(splashAnimate)   ; Do splash ...
0BA1: FE 00           CP      $00                 ; ... animations?
0BA3: C2 AE 0B        JP      NZ,$0BAE            ; Not 0 ... not on this screen
0BA6: 21 11 33        LD      HL,$3311            ; Screen coordinates
0BA9: 3E 02           LD      A,$02               ; Character "C"
0BAB: CD FF 08        CALL    DrawChar            ; Put an extra "C" for "CCOIN" on the screen
0BAE: 01 9C 1F        LD      BC,$1F9C            ; "<1 OR 2 PLAYERS>  "
0BB1: CD 56 18        CALL    ReadPriStruct       ; Load the screen,pointer
0BB4: CD 4C 18        CALL    $184C               ; Print the message
0BB7: DB 02           IN      A,(INP2)            ; Display coin info (bit 7) ...
0BB9: 07              RLCA                        ; ... on demo screen?
0BBA: DA C3 0B        JP      C,$0BC3             ; 1 means no ... skip it
0BBD: 01 A0 1F        LD      BC,$1FA0            ; "*1 PLAYER  1 COIN "
0BC0: CD 3A 18        CALL    $183A               ; Load the descriptor
0BC3: CD B6 0A        CALL    TwoSecDelay         ; Print TWO descriptors worth
0BC6: 3A EC 20        LD      A,(splashAnimate)   ; Doing splash ...
0BC9: FE 00           CP      $00                 ; ... animation?
0BCB: C2 DA 0B        JP      NZ,$0BDA            ; Not 0 ... not on this screen
0BCE: 11 D5 1F        LD      DE,$1FD5            ; Animation for small alien to line up with extra "C"
0BD1: CD E2 0A        CALL    IniSplashAni        ; Copy the animation block
0BD4: CD 80 0A        CALL    Animate             ; Wait for the animation to complete
0BD7: CD 9E 18        CALL    $189E               ; Animate alien shot to extra "C"
0BDA: 21 EC 20        LD      HL,$20EC            ; Toggle ...
0BDD: 7E              LD      A,(HL)              ; ... the ...
0BDE: 3C              INC     A                   ; ... splash screen ...
0BDF: E6 01           AND     $01                 ; ... animation for ...
0BE1: 77              LD      (HL),A              ; ... next time
0BE2: CD D6 09        CALL    ClearPlayField      ; Clear play field
0BE5: C3 DF 18        JP      $18DF               ; Keep splashing
*/  
}
in rom @ 0xBE8 {
  de = 0x1DAB;
  PrintMessageDel();
  ^goto 0xB0B as func;
  /*
0BE8: 11 AB 1D        LD      DE,$1DAB            ; "PLAY" with normal 'Y'
0BEB: CD 93 0A        CALL    PrintMessageDel     ; Print it
0BEE: C3 0B 0B        JP      $0B0B               ; Continue with splash (HL will be pointing to next message)
*/
  PlyrShotAndBump();
  ^goto CheckHiddenMes;
  /*
0BF1: CD 0A 19        CALL    PlyrShotAndBump     ; Check if player is shot and aliens bumping the edge of screen
0BF4: C3 9A 19        JP      CheckHiddenMes      ; Check for hidden-message display sequence
*/
  
}

in rom @ 0xBF7 {
MessageCorp:

  const data_bf7 : [u8] = [
    0x13, 0x00, 0x08, 0x13,
    0x0e, 0x26, 0x02, 0x0e, 0x0f
  ];
  /*
; "TAITO COP"
0BF7: 13 00 08 13 0E 26 02 0E 0F
  */
}
//  repeat
in rom @ 0x1400 {
/*
; The only differences between this and EraseSimpleSprite is two CPL instructions in the latter and
; the use of AND instead of OR. NOP takes the same amount of time/space as CPL. So the two NOPs
; here make these two parallel routines the same size and speed.
*/
func DrawShiftedSprite() {
  nop();
  CnvtPixNumber();
  nop();
  ^do {
  push(bc);
  push(hl);
  a = *(de as *u8);
  io_write(io.SHFT_DATA,a);
  a = io_read(io.SHFT_IN);
  a = a | *(hl as *u8);
  *(hl as *u8) = a;
  hl++;
  de++;
  a = a ^ a;
  io_write(io.SHFT_DATA,a);
  a = io_read(io.SHFT_IN);
  a = a | *(hl as *u8);
  *(hl as *u8) = a;
  hl = pop();
  bc = 0x20;
  hl +=bc;
  bc = pop();
  b--;
  } while !zero;
  
}
/*
1400: 00              NOP                         ; Time/size pad to match CPL in EraseShiftedSprite
1401: CD 74 14        CALL    CnvtPixNumber       ; Convert pixel number to coord and shift
1404: 00              NOP                         ; Time/size pad to match CPL in EraseShiftedSprite
1405: C5              PUSH    BC                  ; Hold count
1406: E5              PUSH    HL                  ; Hold start coordinate
1407: 1A              LD      A,(DE)              ; Get the picture bits
1408: D3 04           OUT     (SHFT_DATA),A       ; Store in shift register
140A: DB 03           IN      A,(SHFT_IN)         ; Read the shifted pixels
140C: B6              OR      (HL)                ; OR them onto the screen
140D: 77              LD      (HL),A              ; Store them back to screen
140E: 23              INC     HL                  ; Next colummn on screen
140F: 13              INC     DE                  ; Next in picture
1410: AF              XOR     A                   ; Shift over ...
1411: D3 04           OUT     (SHFT_DATA),A       ; ... to next byte in register (shift in 0)
1413: DB 03           IN      A,(SHFT_IN)         ; Read the shifted pixels
1415: B6              OR      (HL)                ; OR them onto the screen
1416: 77              LD      (HL),A              ; Store them back to screen
1417: E1              POP     HL                  ; Restore starting coordinate
1418: 01 20 00        LD      BC,$0020            ; Add 32 ...
141B: 09              ADD     HL,BC               ; ... to coordinate (move to next row)
141C: C1              POP     BC                  ; Restore count
141D: 05              DEC     B                   ; All done?
141E: C2 05 14        JP      NZ,$1405            ; No ... go do all rows
1421: C9              RET                         ; Done
*/
  nop();
  nop();
  /*
1422: 00 00 ; ** Why?  
  */
}
  
  
in rom @ 0x1424 {
/*
; Clear a sprite from the screen (standard pixel number descriptor).
; ** We clear 2 bytes even though the draw-simple only draws one.
*/
   func EraseSimpleSprite() {
     CnvtPixNumber();
     ^do {
       push(bc);
       push(hl);
       a = a ^ a;
       *(hl as *u8) = a;
       hl++;
       *(hl as *u8) = a;
       hl++;
       hl = pop();
       bc = 0x20;
       hl+=bc;
       bc = pop();
       b--;
     } while !zero;
 /*
1424: CD 74 14        CALL    CnvtPixNumber       ; Convert pixel number in HL
1427: C5              PUSH    BC                  ; Hold
1428: E5              PUSH    HL                  ; Hold
1429: AF              XOR     A                   ; 0
142A: 77              LD      (HL),A              ; Clear screen byte
142B: 23              INC     HL                  ; Next byte
142C: 77              LD      (HL),A              ; Clear byte
142D: 23              INC     HL                  ; ** Is this to mimic timing? We increment then pop
142E: E1              POP     HL                  ; Restore screen coordinate
142F: 01 20 00        LD      BC,$0020            ; Add 1 row ...
1432: 09              ADD     HL,BC               ; ... to screen coordinate
1433: C1              POP     BC                  ; Restore counter
1434: 05              DEC     B                   ; All rows done?
1435: C2 27 14        JP      NZ,$1427            ; Do all rows
1438: C9              RET                         ; out
*/
   }
}

in rom @ 0x1439 {
/*
; Display character to screen
; HL = screen coordinates
; DE = character data
; B = number of rows
*/
  func DrawSimpSprite() {
    ^do {
      push(bc);
      a = *(de as *u8);
      *(hl as *u8) = a;
      de++;
      bc = 0x20;
      hl+=bc;
      bc = pop();
      b--;
    } while !zero;
/*
1439: C5              PUSH    BC                  ; Preserve counter
143A: 1A              LD      A,(DE)              ; From character set ...
143B: 77              LD      (HL),A              ; ... to screen
143C: 13              INC     DE                  ; Next in character set
143D: 01 20 00        LD      BC,$0020            ; Next row ...
1440: 09              ADD     HL,BC               ; ... on screen
1441: C1              POP     BC                  ; Restore counter
1442: 05              DEC     B                   ; Decrement counter
1443: C2 39 14        JP      NZ,DrawSimpSprite   ; Do all
1446: C9              RET                         ; Out
*/
    
  }
  const data_1447 : [u8] = [
    0,0,0,0,0,0,0,0,0,0,0
  ];
    
  /*
  1447: 00 00 00 00 00 00 00 00 00 00 00 ; ** Why?
  */                        
  
}

in rom @ 0x1452 {
// Erases a shifted sprite from screen (like for player's explosion)
  EraseShifted:
  CnvtPixNumber();
  ^do {
    push(bc);
    push(hl);
    a = *(de as *u8);
    io_write(io.SHFT_DATA,a);
    a = io_read(io.SHFT_IN);
//    nop();
    const data_145C : u8 = 0x2f; // cpl
    a = a & *(hl as *u8);
    *(hl as *u8) = a;
    hl++;
    de++;
    a = a ^ a;
    io_write(io.SHFT_DATA,a);
    a = io_read(io.SHFT_IN);
    const data1466 : u8 = 0x2f; // cpl
    a = a & *(hl as *u8);
    *(hl as *u8) = a;
    hl = pop();
    bc = 0x20;
    hl += bc;
    bc = pop();
    b--;
  } while !zero;
  return;
  /*
  1452: CD 74 14        CALL    CnvtPixNumber       ; Convert pixel number in HL to coorinates with shift
1455: C5              PUSH    BC                  ; Hold BC
1456: E5              PUSH    HL                  ; Hold coordinate
1457: 1A              LD      A,(DE)              ; Get picture value
1458: D3 04           OUT     (SHFT_DATA),A       ; Value into shift register
145A: DB 03           IN      A,(SHFT_IN)         ; Read shifted sprite picture
145C: 2F              CPL                         ; Reverse it (erasing bits)
145D: A6              AND     (HL)                ; Erase the bits from the screen
145E: 77              LD      (HL),A              ; Store the erased pattern back
145F: 23              INC     HL                  ; Next column on screen
1460: 13              INC     DE                  ; Next in image
1461: AF              XOR     A                   ; Shift register over ...
1462: D3 04           OUT     (SHFT_DATA),A       ; ... 8 bits (shift in 0)
1464: DB 03           IN      A,(SHFT_IN)         ; Read 2nd byte of image
1466: 2F              CPL                         ; Reverse it (erasing bits)
1467: A6              AND     (HL)                ; Erase the bits from the screen
1468: 77              LD      (HL),A              ; Store the erased pattern back
1469: E1              POP     HL                  ; Restore starting coordinate
146A: 01 20 00        LD      BC,$0020            ; Add 32 ...
146D: 09              ADD     HL,BC               ; ... to next row
146E: C1              POP     BC                  ; Restore BC (count)
146F: 05              DEC     B                   ; All rows done?
1470: C2 55 14        JP      NZ,$1455            ; No ... erase all
1473: C9              RET                         ; Done
  */
  
}
  
in rom @ 0x1474 {
  CnvtPixNumber:
  a=l;
  a = a & 7;
  io_write(io.SHFTAMNT,a);
  ^goto ConvToScr;
  /*
; Convert pixel number in HL to screen coordinate and shift amount.
; HL gets screen coordinate.
; Hardware shift-register gets amount.
1474: 7D              LD      A,L                 ; Get X coordinate
1475: E6 07           AND     $07                 ; Shift by pixel position
1477: D3 02           OUT     (SHFTAMNT),A        ; Write shift amount to hardware
1479: C3 47 1A        JP      ConvToScr           ; HL = HL/8 + 2000 (screen coordinate)
*/
}
  
in rom @ 0x147C {
  
/*
; In a multi-player game the player's shields are block-copied to and from RAM between turns.
; HL = screen pointer
; DE = memory buffer
; B = number of rows
; C = number of columns
*/
  func RememberShields() {
    ^do {
      push(bc);
      push(hl);
      ^do {
        a = *(hl as *u8);
        *(de as *u8) = a;
        de++;
        hl++;
        c--;
      } while !zero;
      hl = pop();
      bc = 0x20;
      hl+=bc;
      bc = pop();
      b--;
    } while !zero;
/*
147C: C5              PUSH    BC                  ; Hold counter
147D: E5              PUSH    HL                  ; Hold start
147E: 7E              LD      A,(HL)              ; From sprite ... (should be DE)
147F: 12              LD      (DE),A              ; ... to screen ... (should be HL)
1480: 13              INC     DE                  ; Next in sprite
1481: 23              INC     HL                  ; Next on screen
1482: 0D              DEC     C                   ; All columns done?
1483: C2 7E 14        JP      NZ,$147E            ; No ... do multi columns
1486: E1              POP     HL                  ; Restore screen start
1487: 01 20 00        LD      BC,$0020            ; Add 32 ...
148A: 09              ADD     HL,BC               ; ... to get to next row
148B: C1              POP     BC                  ; Pop the counters
148C: 05              DEC     B                   ; All rows done?
148D: C2 7C 14        JP      NZ,RememberShields  ; No ... do multi rows
1490: C9              RET                         ; Done
*/
  }
}
  

in rom @ 0x1491 {
func DrawSprCollision() {
  CnvtPixNumber();
  a = a ^ a;
  collision = a;
  ^do {
    push(bc);
    push(hl);
    a = *(de as *u8);
    io_write(io.SHFT_DATA,a);
    a = io_read(io.SHFT_IN);
    push(af);
    a = a & *(hl as *u8);
    ^if !zero {
      a = 1;
      collision = a;
    }
    af = pop();
    a = a | *(hl as *u8);
    *(hl as *u8) = a;
    hl++;
    de++;
    a = a ^ a;
    io_write(io.SHFT_DATA,a);
    a = io_read(io.SHFT_IN);
    push(af);
    a = a & *(hl as *u8);
    ^if !zero {
      a = 1;
      collision = a;
    }
    af = pop();
    a = a | *(hl as *u8);
    *(hl as *u8) = a;
    hl = pop();
    bc = 0x20;
    hl+=bc;
    bc = pop();
    b--;
  } while !zero;

  /*
1491: CD 74 14        CALL    CnvtPixNumber       ; Convert pixel number to coord and shift
1494: AF              XOR     A                   ; Clear the ...
1495: 32 61 20        LD      (collision),A       ; ... collision-detection flag
1498: C5              PUSH    BC                  ; Hold count
1499: E5              PUSH    HL                  ; Hold screen
149A: 1A              LD      A,(DE)              ; Get byte
149B: D3 04           OUT     (SHFT_DATA),A       ; Write first byte to shift register
149D: DB 03           IN      A,(SHFT_IN)         ; Read shifted pattern
149F: F5              PUSH    AF                  ; Hold the pattern
14A0: A6              AND     (HL)                ; Any bits from pixel collide with bits on screen?
14A1: CA A9 14        JP      Z,$14A9             ; No ... leave flag alone
14A4: 3E 01           LD      A,$01               ; Yes ... set ...
14A6: 32 61 20        LD      (collision),A       ; ... collision flag
14A9: F1              POP     AF                  ; Restore the pixel pattern
14AA: B6              OR      (HL)                ; OR it onto the screen
14AB: 77              LD      (HL),A              ; Store new screen value
14AC: 23              INC     HL                  ; Next byte on screen
14AD: 13              INC     DE                  ; Next in pixel pattern
14AE: AF              XOR     A                   ; Write zero ...
14AF: D3 04           OUT     (SHFT_DATA),A       ; ... to shift register
14B1: DB 03           IN      A,(SHFT_IN)         ; Read 2nd half of shifted sprite
14B3: F5              PUSH    AF                  ; Hold pattern
14B4: A6              AND     (HL)                ; Any bits from pixel collide with bits on screen?
14B5: CA BD 14        JP      Z,$14BD             ; No ... leave flag alone
14B8: 3E 01           LD      A,$01               ; Yes ... set ...
14BA: 32 61 20        LD      (collision),A       ; ... collision flag
14BD: F1              POP     AF                  ; Restore the pixel pattern
14BE: B6              OR      (HL)                ; OR it onto the screen
14BF: 77              LD      (HL),A              ; Store new screen pattern
14C0: E1              POP     HL                  ; Starting screen coordinate
14C1: 01 20 00        LD      BC,$0020            ; Add 32 ...
14C4: 09              ADD     HL,BC               ; ... to get to next row
14C5: C1              POP     BC                  ; Restore count
14C6: 05              DEC     B                   ; All done?
14C7: C2 98 14        JP      NZ,$1498            ; No ... do all rows
14CA: C9              RET                         ; Done
*/
  }
  
}
  
in rom @ 0x14CB {
// Clear a one byte sprite at HL. B=number of rows.

  func ClearSmallSprite() {
    a = a ^ a;
    ^do {
      push(bc);
      *(hl as *u8) = a;
      bc = 0x20;
      hl += bc;
      bc = pop();
      b--;
    } while !zero;
/*
14CB: AF              XOR     A                   ; 0
14CC: C5              PUSH    BC                  ; Preserve BC
14CD: 77              LD      (HL),A              ; Clear screen byte
14CE: 01 20 00        LD      BC,$0020            ; Bump HL ...
14D1: 09              ADD     HL,BC               ; ... one screen row
14D2: C1              POP     BC                  ; Restore
14D3: 05              DEC     B                   ; All done?
14D4: C2 CC 14        JP      NZ,$14CC            ; No ... clear all
14D7: C9              RET                         
*/
  }
}

in rom @ 0x14D8 {
/*
; The player's shot hit something (or is being removed from play)
;*/
  PlayerShotHit:
  a = plyrShotStatus;
  cmp(a,5);
  return if zero;
  cmp(a,2);
  return if !zero;
/*
14D8: 3A 25 20        LD      A,(plyrShotStatus)  ; Player shot flag
14DB: FE 05           CP      $05                 ; Alien explosion in progress?
14DD: C8              RET     Z                   ; Yes ... ignore this function
14DE: FE 02           CP      $02                 ; Normal movement?
14E0: C0              RET     NZ                  ; No ... out
*/
  a = obj1CoorYr;
  cmp(a,0xd8);
  b = a;
  ^goto (0x1530 as func) if !carry;
  a = alienIsExploding;
  a = a & a;
  return if zero;
/*  
14E1: 3A 29 20        LD      A,(obj1CoorYr)      ; Get Yr coordinate of player shot
14E4: FE D8           CP      $D8                 ; Compare to 216 (40 from Top-rotated)
14E6: 47              LD      B,A                 ; Hold value for later
14E7: D2 30 15        JP      NC,$1530            ; Yr is within 40 from top initiate miss-explosion (shot flag 3)
14EA: 3A 02 20        LD      A,(alienIsExploding); Is an alien ...
14ED: A7              AND     A                   ; ... blowing up?
14EE: C8              RET     Z                   ; No ... out
*/
  a = b;
  cmp(a,0xce);
  ^goto (0x1579 as func) if !carry;
  a += 6;
  b = a;
  a = refAlienYr;
/*
14EF: 78              LD      A,B                 ; Get original Yr coordinate back to A
14F0: FE CE           CP      $CE                 ; Compare to 206 (50 from rotated top)
14F2: D2 79 15        JP      NC,$1579            ; Yr is within 50 from top? Yes ... saucer must be hit
14F5: C6 06           ADD     A,$06               ; Offset to coordinate for wider "explosion" picture
14F7: 47              LD      B,A                 ; Hold that
14F8: 3A 09 20        LD      A,(refAlienYr)      ; Ref alien Y coordianate
  */
}

in rom @ 0x14FB {
/*
; If the lower 4 rows are all empty then the reference alien's Y coordinate will wrap around from 0 to F8.
; At this point the top row of aliens is in the shields and we will assume that everything is within
; the rack.
*/
  cmp(a,0x90);
  ^goto CodeBug1 if !carry;
  cmp(a,b);
  ^goto (0x1530 as func) if !carry;
/*  
14FB: FE 90           CP      $90                 ; This is true if ...
14FD: D2 04 15        JP      NC,CodeBug1         ; ... aliens are down in the shields
1500: B8              CP      B                   ; Compare to shot's coordinate
1501: D2 30 15        JP      NC,$1530            ; Outside the rack-square ... do miss explosion
  */  
}
  
in rom @ 0x1504 {
/*
;
; We get here if the player's shot hit something within the rack area (a shot or an alien).
; Find the alien that is (or would be) where the shot hit. If there is no alien alive at the row/column
; thn the player hit an alien missile. If there is an alien then explode the alien.
;
; There is a code bug here, but it is extremely subtle. The algorithm for finding the row/column in the
; rack works by adding 16 to the reference coordinates (X for column, Y for row) until it passes or equals
; the target coordinates. This works great as long as the target point is within the alien's rack area.
; If the reference point is far to the right, the column number will be greater than 11, which messes
; up the column/row-to-pointer math.
;
; The entire rack of aliens is based on the lower left alien. Imagine all aliens are dead except the
; upper left. It wiggles down the screen and enters the players shields on the lower left where it begins
; to eat them. Imagine the player is under his own shields on the right side of the screen and fires a
; shot into his own shield.
;
; The alien is in the rack on row 4 (rows are numbered from bottom up starting with 0). The shot hits
; the shields below the alien's Y coordinate and gets correctly assigned to row 3. The alien is in the rack
; at column 0 (columns are numbered from left to right starting with 0). The shot hits the shields far to
; the right of the alien's X coordinate. The algorithm says it is in column 11. But 0-10 are the only
; correct values.
;
; The column/row-to-pointer math works by multiplying the row by 11 and adding the column. For the alien
; that is 11*4 + 0 = 44. For the shot that is 11*3 +11 = 44. The game thinks the shot hit the alien.
*/
  CodeBug1:
  l = b;
  FindRow();
  a = obj1CoorXr;
  h = a;
  FindColumn();
  expAlienCr = hl;
  a = 5;
  plyrShotStatus = a;
  GetAlienStatPtr();
  a = *(hl as *u8);
  a = a & a;
  ^goto (0x1530 as func) if zero;
/*
1504: 68              LD      L,B                 ; L now holds the shot coordinate (adjusted)
1505: CD 62 15        CALL    FindRow             ; Look up row number to B
1508: 3A 2A 20        LD      A,(obj1CoorXr)      ; Player's shot's Xr coordinate ...
150B: 67              LD      H,A                 ; ... to H
150C: CD 6F 15        CALL    FindColumn          ; Get alien's coordinate
150F: 22 64 20        LD      (expAlienYr),HL     ; Put it in the exploding-alien descriptor
1512: 3E 05           LD      A,$05               ; Flag alien explosion ...
1514: 32 25 20        LD      (plyrShotStatus),A  ; ... in progress
1517: CD 81 15        CALL    GetAlienStatPtr     ; Get descriptor for alien
151A: 7E              LD      A,(HL)              ; Is alien ...
151B: A7              AND     A                   ; ... alive
151C: CA 30 15        JP      Z,$1530             ; No ... must have been an alien shot
*/
  *(hl as *u8) = 0;
  ScoreForAlien();
  ReadDesc();
  DrawSprite();
  a = 0x10;
  expAlienTimer = a;
  return;
/*  
151F: 36 00           LD      (HL),$00            ; Make alien invader dead
1521: CD 5F 0A        CALL    ScoreForAlien       ; Makes alien explosion sound and adjust score
1524: CD 3B 1A        CALL    ReadDesc            ; Load 5 byte sprite descriptor
1527: CD D3 15        CALL    DrawSprite          ; Draw explosion sprite on screen
152A: 3E 10           LD      A,$10               ; Initiate alien-explosion
152C: 32 03 20        LD      (expAlienTimer),A   ; ... timer to 16
152F: C9              RET                         ; Out
*/
  
// Player shot leaving playfield, hitting shield, or hitting an alien shot
  a = 3;
  plyrShotStatus = a;
  ^goto (0x154A as func);
/*
1530: 3E 03           LD      A,$03               ; Mark ...
1532: 32 25 20        LD      (plyrShotStatus),A  ; ... player shot hit something other than alien
1535: C3 4A 15        JP      $154A               ; Finish up
;  
  */
}
in rom @ 0x1538 {
/*
; Time down the alien explosion. Remove when done.
*/
  AExplodeTime:
  hl = 0x2003;
  --*(hl as *u8);
  return if !zero;
  hl = expAlienCr;
  b = 0x10;
  EraseSimpleSprite();
  a = 4;
  plyrShotStatus = a;
  a = a ^ a;
  alienIsExploding = a;
  b = 0xf7;
  ^goto SoundBits3Off;
/*
1538: 21 03 20        LD      HL,$2003            ; Decrement alien explosion ...
153B: 35              DEC     (HL)                ; ... timer
153C: C0              RET     NZ                  ; Not done  ... out
153D: 2A 64 20        LD      HL,(expAlienYr)     ; Pixel pointer for exploding alien
1540: 06 10           LD      B,$10               ; 16 row pixel
1542: CD 24 14        CALL    EraseSimpleSprite   ; Clear the explosion sprite from the screen
1545: 3E 04           LD      A,$04               ; 4 means that ...
1547: 32 25 20        LD      (plyrShotStatus),A  ; ... alien has exploded (remove from active duty)
;
154A: AF              XOR     A                   ; Turn off ...
154B: 32 02 20        LD      (alienIsExploding),A; ... alien-is-blowing-up flag
154E: 06 F7           LD      B,$F7               ; Turn off ...
1550: C3 DC 19        JP      SoundBits3Off       ; ... alien exploding sound
*/
  nop();
/*
1553: 00            
*/
}
  

in rom @ 0x1554 {
Cnt16s:
/*; Count number of 16s needed to bring reference (in A) up to target (in H).
; If the reference starts out beyond the target then we add 16s as long as
; the reference has a signed bit. But these aren't signed quantities. This
; doesn't make any sense. This counting algorithm produces questionable
; results if the reference is beyond the target.
;
*/
  c = 0;
  cmp(a,h);
  const data1557 : [u8] = [0xD4, 0x90, 0x15];
  ^while true {
    cmp(a,h);
    return if !carry;
    a = a + 0x10;
    c++;
  };
  
  /*
1554: 0E 00           LD      C,$00               ; Count of 16s
1556: BC              CP      H                   ; Compare reference coordinate to target
1557: D4 90 15        CALL    NC,WrapRef          ; If reference is greater or equal then do something questionable ... see below
155A: BC              CP      H                   ; Compare reference coordinate to target
155B: D0              RET     NC                  ; If reference is greater or equal then done
155C: C6 10           ADD     A,$10               ; Add 16 to reference
155E: 0C              INC     C                   ; Bump 16s count
155F: C3 5A 15        JP      $155A               ; Keep testing
  */
  
}
  
in rom @ 0x1562 {
/*
; L contains a Yr coordinate. Find the row number within the rack that corresponds
; to the Yr coordinate. Return the row coordinate in L and the row number in C.
;
*/
  func FindRow() {
    a = refAlienYr;
    h = l;
    Cnt16s();
    b = c;
    b--;
    a = a -# 0x10;
    l = a;
/*
1562: 3A 09 20        LD      A,(refAlienYr)      ; Reference alien Yr coordinate
1565: 65              LD      H,L                 ; Target Yr coordinate to H
1566: CD 54 15        CALL    Cnt16s              ; Count 16s needed to bring ref alien to target
1569: 41              LD      B,C                 ; Count to B
156A: 05              DEC     B                   ; Base 0
156B: DE 10           SBC     A,$10               ; The counting also adds 16 no matter what
156D: 6F              LD      L,A                 ; To coordinate
156E: C9              RET                         ; Done
  */
  }
}
in rom @ 0x156F {
/*
; H contains a Xr coordinate. Find the column number within the rack that corresponds
; to the Xr coordinate. Return the column coordinate in H and the column number in C.
;
*/
  func FindColumn() {
    a = refAlienXr;
    Cnt16s();
    a = a -#0x10;
    h = a;

/*
156F: 3A 0A 20        LD      A,(refAlienXr)      ; Reference alien Yn coordinate
1572: CD 54 15        CALL    Cnt16s              ; Count 16s to bring Y to target Y
1575: DE 10           SBC     A,$10               ; Subtract off extra 16
1577: 67              LD      H,A                 ; To H
1578: C9              RET                         ; Done
*/
  }
  a = 1;
  saucerHit = a;
  ^goto (0x1545 as func);
  /*
1579: 3E 01           LD      A,$01               ; Mark flying ...
157B: 32 85 20        LD      (saucerHit),A       ; ... saucer has been hit
157E: C3 45 15        JP      $1545               ; Remove player shot
  */
  
}

in rom @ 0x1581 {
/*
; B is row number. C is column number (starts at 1).
; Return pointer to alien-status flag for current player.
*/
  GetAlienStatPtr:
  a = b;
  const data_1582 : [u8;3] = [7,7,7];
  a += b;
  a += b;
  a += b;
  a += c;
  a--;
  l = a;
  a = playerDataMSB;
  h = a;
  return;
/*
1581: 78              LD      A,B                 ; Hold original
1582: 07              RLCA                        ; *2
1583: 07              RLCA                        ; *4
1584: 07              RLCA                        ; *8
1585: 80              ADD     A,B                 ; *9
1586: 80              ADD     A,B                 ; *10
1587: 80              ADD     A,B                 ; *11
1588: 81              ADD     A,C                 ; Add row offset to column offset
1589: 3D              DEC     A                   ; -1
158A: 6F              LD      L,A                 ; Set LSB of HL
158B: 3A 67 20        LD      A,(playerDataMSB)   ; Set ...
158E: 67              LD      H,A                 ; ... MSB of HL with active player indicator
158F: C9              RET                         
  */
  
}
  
in rom @ 0x1590 {
/*
; This is called if the reference point is greater than the target point. I believe the goal is to
; wrap the reference back around until it is lower than the target point. But the algorithm simply adds
; until the sign bit of the the reference is 0. If the target is 2 and the reference is 238 then this
; algorithm moves the reference 238+16=244 then 244+16=4. Then the algorithm stops. But the reference is
; STILL greater than the target.
;
; Also imagine that the target is 20 and the reference is 40. The algorithm adds 40+16=56, which is not
; negative, so it stops there.
;
; I think the intended code is "JP NC" instead of "JP M", but even that doesn't make sense.
;*/
 func WrapRef() {
   ^do {
     c++;
     a = a + 0x10;
   } while negative;
/*
1590: 0C              INC     C                   ; Increase 16s count
1591: C6 10           ADD     A,$10               ; Add 16 to ref
1593: FA 90 15        JP      M,WrapRef           ; Keep going till result is positive
1596: C9              RET                         ; Out
*/
 }
  
}

in rom @ 0x1597 {
/*
; When rack bumps the edge of the screen then the direction flips and the rack
; drops 8 pixels. The deltaX and deltaY values are changed here. Interestingly
; if there is only one alien left then the right value is 3 instead of the
; usual 2. The left direction is always -2.
*/
RackBump:
  a = rackDirection;
  a = a & a;
  ^goto (0x15B7 as func) if !zero;
/*
  1597: 3A 0D 20        LD      A,(rackDirection)   ; Get rack direction
159A: A7              AND     A                   ; Moving right?
159B: C2 B7 15        JP      NZ,$15B7            ; No ... handle moving left
*/
  hl = 0x3EA4;
  (0x15C5 as func)();
  return if !carry;
  b = 0xfe;
  a = 1;
  /*
159E: 21 A4 3E        LD      HL,$3EA4            ; Line down the right edge of playfield
15A1: CD C5 15        CALL    $15C5               ; Check line down the edge
15A4: D0              RET     NC                  ; Nothing is there ... return
15A5: 06 FE           LD      B,$FE               ; Delta X of -2
15A7: 3E 01           LD      A,$01               ; Rack now moving right
*/
  rackDirection = a;
  a = b;
  refAlienDXr = a;
  a = rackDownDelta;
  refAlienDYr = a;
  return;
/*  
15A9: 32 0D 20        LD      (rackDirection),A   ; Set new rack direction
15AC: 78              LD      A,B                 ; B has delta X
15AD: 32 08 20        LD      (refAlienDXr),A     ; Set new delta X
15B0: 3A 0E 20        LD      A,(rackDownDelta)   ; Set delta Y ...
15B3: 32 07 20        LD      (refAlienDYr),A     ; ... to drop rack by 8
15B6: C9              RET                         ; Done
;  
  */
  hl = 0x2524;
  (0x15C5 as func)();
  return if !carry;
  (0x18F1 as func)();
  a = a ^ a;
  ^goto (0x15A9 as func);
/*
15B7: 21 24 25        LD      HL,$2524            ; Line down the left edge of playfield
15BA: CD C5 15        CALL    $15C5               ; Check line down the edge
15BD: D0              RET     NC                  ; Nothing is there ... return
15BE: CD F1 18        CALL    $18F1               ; Get moving-right delta X value of 2 (3 if just one alien left)
15C1: AF              XOR     A                   ; Rack now moving left
15C2: C3 A9 15        JP      $15A9               ; Set rack direction
*/
  b = 0x17;
  ^do {
    a = *(hl as *u8);
    a = a & a;
    ^goto (0x166B as func) if !zero;
    hl++;
    b--;
  } while !zero;
  return;
/*  
15C5: 06 17           LD      B,$17               ; Checking 23 bytes in a line up the screen from near the bottom
15C7: 7E              LD      A,(HL)              ; Get screen memory
15C8: A7              AND     A                   ; Is screen memory empty?
15C9: C2 6B 16        JP      NZ,$166B            ; No ... set carry flag and out
15CC: 23              INC     HL                  ; Next byte on screen
15CD: 05              DEC     B                   ; All column done?
15CE: C2 C7 15        JP      NZ,$15C7            ; No ... keep looking
15D1: C9              RET                         ; Return with carry flag clear
*/
  nop();
/*
15D2: 00              NOP                         ; ** Why? Something optimized?
  */  
}
  

  
in rom @ 0x15D3 {
  DrawSprite:
  CnvtPixNumber();
  push(hl);
  ^do {
  push(bc);
  push(hl);
  a = *(de as *u8);
  io_write(io.SHFT_DATA,a);
  a = io_read(io.SHFT_IN);
  *(hl as *u8) = a;
  hl++;
  de++;
  a = a ^ a;
  io_write(io.SHFT_DATA,a);
  a = io_read(io.SHFT_IN);
  *(hl as *u8) = a;
  hl = pop();
  bc = 0x20;
  hl +=bc;
  bc = pop();
  b--;
} while !zero;
  hl = pop();
  return;
  /*; Draw sprite at [DE] to screen at pixel position in HL
; The hardware shift register is used in converting pixel positions
; to screen coordinates.
15D3: CD 74 14        CALL    CnvtPixNumber       ; Convert pixel number to screen/shift
15D6: E5              PUSH    HL                  ; Preserve screen coordinate
15D7: C5              PUSH    BC                  ; Hold for a second
15D8: E5              PUSH    HL                  ; Hold for a second
15D9: 1A              LD      A,(DE)              ; From sprite data
15DA: D3 04           OUT     (SHFT_DATA),A       ; Write data to shift register
15DC: DB 03           IN      A,(SHFT_IN)         ; Read back shifted amount
15DE: 77              LD      (HL),A              ; Shifted sprite to screen
15DF: 23              INC     HL                  ; Adjacent cell
15E0: 13              INC     DE                  ; Next in sprite data
15E1: AF              XOR     A                   ; 0
15E2: D3 04           OUT     (SHFT_DATA),A       ; Write 0 to shift register
15E4: DB 03           IN      A,(SHFT_IN)         ; Read back remainder of previous
15E6: 77              LD      (HL),A              ; Write remainder to adjacent
15E7: E1              POP     HL                  ; Old screen coordinate
15E8: 01 20 00        LD      BC,$0020            ; Offset screen ...
15EB: 09              ADD     HL,BC               ; ... to next row
15EC: C1              POP     BC                  ; Restore count
15ED: 05              DEC     B                   ; All done?
15EE: C2 D7 15        JP      NZ,$15D7            ; No ... do all
15F1: E1              POP     HL                  ; Restore HL
15F2: C9              RET                         ; Done
*/
}
  
in rom @ 0x15F3 {
/*
; Count number of aliens remaining in active game and return count 2082 holds the current count.
; If only 1, 206B gets a flag of 1 ** but ever nobody checks this
*/
  func CountAliens() {
    GetPlayerDataPtr();
    bc = 0x3700;
    ^do {
      a = *(hl as *u8);
      a = a & a;
      ^if !zero {
        c++;
      }
      hl++;
      b--;
    } while !zero;
    a = c;
    numAliens = a;
    cmp(a,1);
    return if !zero;
    hl = 0x206B;
    *(hl as *u8) = 1;
/*
15F3: CD 11 16        CALL    GetPlayerDataPtr    ; Get active player descriptor
15F6: 01 00 37        LD      BC,$3700            ; B=55 aliens to check?
15F9: 7E              LD      A,(HL)              ; Get byte
15FA: A7              AND     A                   ; Is it a zero?
15FB: CA FF 15        JP      Z,$15FF             ; Yes ... don't count it
15FE: 0C              INC     C                   ; Count the live aliens
15FF: 23              INC     HL                  ; Next alien
1600: 05              DEC     B                   ; Count ...
1601: C2 F9 15        JP      NZ,$15F9            ; ... all alien indicators
1604: 79              LD      A,C                 ; Get the count
1605: 32 82 20        LD      (numAliens),A       ; Hold it
1608: FE 01           CP      $01                 ; Just one?
160A: C0              RET     NZ                  ; No keep going
160B: 21 6B 20        LD      HL,$206B            ; Set flag if ...
160E: 36 01           LD      (HL),$01            ; ... only one alien left
1610: C9              RET                         ; Out
*/
  }
}
  
in rom @ 0x1611 {
/*
; Set HL with 2100 if player 1 is active or 2200 if player 2 is active
;*/
 func GetPlayerDataPtr() {
   l = 0;
   a = playerDataMSB;
   h = a;
/*
1611: 2E 00           LD      L,$00               ; Byte boundary
1613: 3A 67 20        LD      A,(playerDataMSB)   ; Active player number
1616: 67              LD      H,A                 ; Set HL to data
1617: C9              RET                         ; Done
*/
 }
}
in rom @ 0x1618 {
/*
; Initiate player fire if button is pressed.
; Demo commands are parsed here if in demo mode
*/
  PlrFireOrDemo:
  a = playerAlive;
  cmp(a,0xff);
  return if !zero;
  hl = 0x2010;
  a = *(hl as *u8);
  hl++;
  b = *(hl as *u8);
  a = a | b;
  return if !zero;
  a = plyrShotStatus;
  a = a & a;
  return if !zero;
  a = gameMode;
  a = a & a;
  ^if !zero {
    a = fireBounce;
    a = a & a;
    ^if zero {
      ReadInputs();
      a = a & 0x10;
      return if zero;
      a = 1;
      plyrShotStatus = a;
      fireBounce = a;
      return;
    }
    ReadInputs();
    a = a & 0x10;
    return if !zero;
    fireBounce = a;
    return;
  }
/*
1618: 3A 15 20        LD      A,(playerAlive)     ; Is there an active player?
161B: FE FF           CP      $FF                 ; FF = alive
161D: C0              RET     NZ                  ; Player has been shot - no firing
161E: 21 10 20        LD      HL,$2010            ; Get player ...
1621: 7E              LD      A,(HL)              ; ... task ...
1622: 23              INC     HL                  ; ... timer ...
1623: 46              LD      B,(HL)              ; ... value
1624: B0              OR      B                   ; Is the timer 0 (object active)?
1625: C0              RET     NZ                  ; No ... no firing till player object starts
1626: 3A 25 20        LD      A,(plyrShotStatus)  ; Does the player have ...
1629: A7              AND     A                   ; ... a shot on the screen?
162A: C0              RET     NZ                  ; Yes ... ignore
162B: 3A EF 20        LD      A,(gameMode)        ; Are we in ...
162E: A7              AND     A                   ; ... game mode?
162F: CA 52 16        JP      Z,$1652             ; No ... in demo mode ... constant firing in demo
1632: 3A 2D 20        LD      A,(fireBounce)      ; Is fire button ...
1635: A7              AND     A                   ; ... being held down?
1636: C2 48 16        JP      NZ,$1648            ; Yes ... wait for bounce
1639: CD C0 17        CALL    ReadInputs          ; Read active player controls
163C: E6 10           AND     $10                 ; Fire-button pressed?
163E: C8              RET     Z                   ; No ... out
163F: 3E 01           LD      A,$01               ; Flag
1641: 32 25 20        LD      (plyrShotStatus),A  ; Flag shot active
1644: 32 2D 20        LD      (fireBounce),A      ; Flag that fire button is down
1647: C9              RET                         ; Out
1648: CD C0 17        CALL    ReadInputs          ; Read active player controls
164B: E6 10           AND     $10                 ; Fire-button pressed?
164D: C0              RET     NZ                  ; Yes ... ignore
164E: 32 2D 20        LD      (fireBounce),A      ; Else ... clear flag
1651: C9              RET                         ; Out  
  */
//  ; Handle demo (constant fire, parse demo commands)
  hl = 0x2025;
  *(hl as *u8) = 1;
  hl = demoCmdPtr;
  hl++;
  a = l;
  cmp(a,0x7e);
  ^if !carry {
    l = 0x74;
  }
  demoCmdPtr = hl;
  a = *(hl as *u8);
  nextDemoCmd = a;
  return;
/*
1652: 21 25 20        LD      HL,$2025            ; Demo fires ...
1655: 36 01           LD      (HL),$01            ; ... constantly
1657: 2A ED 20        LD      HL,(demoCmdPtrLSB)  ; Demo command bufer
165A: 23              INC     HL                  ; Next position
165B: 7D              LD      A,L                 ; Command buffer ...
165C: FE 7E           CP      $7E                 ; ... wraps around
165E: DA 63 16        JP      C,$1663             ; ... Buffer from 1F74 to 1F7E
1661: 2E 74           LD      L,$74               ; ... overflow
1663: 22 ED 20        LD      (demoCmdPtrLSB),HL  ; Next demo command
1666: 7E              LD      A,(HL)              ; Get next command
1667: 32 1D 20        LD      (nextDemoCmd),A     ; Set command for movement
166A: C9              RET                         ; Done
*/
  carry = true;
  return;
}
  
/*in rom @ 0x1652 {
  
  
}*/
in rom @ 0x166d {  
  a = a ^ a;
  (0x1A8B as func)();
  CurPlyAlive();
  *(hl as *u8) = 0;
  (0x9Ca as func)();
  hl++;
  de = 0x20F5;
  a = *(de as *u8);
  cmp (a, *(hl as *u8));
  de --;
  hl --;
  a = *(de as *u8);
  ^goto (0x168B as func) if zero;
  ^goto (0x1698 as func) if !carry;
  ^goto (0x168F as func);
  
  /*
166D: AF              XOR     A                   ; 0
166E: CD 8B 1A        CALL    $1A8B               ; Print ZERO ships remain
1671: CD 10 19        CALL    CurPlyAlive         ; Get active-flag ptr for current player
1674: 36 00           LD      (HL),$00            ; Flag player is dead
1676: CD CA 09        CALL    $09CA               ; Get score descriptor for current player
1679: 23              INC     HL                  ; Point to high two digits
167A: 11 F5 20        LD      DE,$20F5            ; Current high score upper two digits
167D: 1A              LD      A,(DE)              ; Is player score greater ...
167E: BE              CP      (HL)                ; ... than high score?
167F: 1B              DEC     DE                  ; Point to LSB
1680: 2B              DEC     HL                  ; Point to LSB
1681: 1A              LD      A,(DE)              ; Go ahead and fetch high score lower two digits
1682: CA 8B 16        JP      Z,$168B             ; Upper two are the same ... have to check lower two
1685: D2 98 16        JP      NC,$1698            ; Player score is lower than high ... nothing to do
1688: C3 8F 16        JP      $168F               ; Player socre is higher ... go copy the new high score
;*/
}

in rom @ 0x168B {
  cmp (a, *(hl as *u8));
  ^if carry {
    a = *(hl as *u8);
    *(de as *u8) = a;
    de++;
    hl++;
    a = *(hl as *u8);
    *(de as *u8) = a;
    PrintHiScore();
  }
  a = twoPlayers;
  a = a & a;
  ^if !zero {
    hl = 0x2803;
    de = 0x1AA6;
    c = 0x14;
    PrintMessageDel();
    h--;
    h--;
    b = 0x1B;
    a = playerDataMSB;
    const data_16b1 : u8 = 0xf;
    ^if !carry {
      b = 0x1c;
    }
    a = b;
    DrawChar();
    OneSecDelay();
    (0x18E7 as func)();
    a = *(hl as *u8);
    a = a & a;
    ^if !zero {
      ^goto (0x02ED as func);
    }
  }
  /*
168B: BE              CP      (HL)                ; Is lower digit higher? (upper was the same)
168C: D2 98 16        JP      NC,$1698            ; No ... high score is still greater than player's score
168F: 7E              LD      A,(HL)              ; Copy the new ...
1690: 12              LD      (DE),A              ; ... high score lower two digits
1691: 13              INC     DE                  ; Point to MSB
1692: 23              INC     HL                  ; Point to MSB
1693: 7E              LD      A,(HL)              ; Copy the new ...
1694: 12              LD      (DE),A              ; ... high score upper two digits
1695: CD 50 19        CALL    PrintHiScore        ; Draw the new high score
1698: 3A CE 20        LD      A,(twoPlayers)      ; Number of players
169B: A7              AND     A                   ; Is this a single player game?
169C: CA C9 16        JP      Z,$16C9             ; Yes ... short message
169F: 21 03 28        LD      HL,$2803            ; Screen coordinates
16A2: 11 A6 1A        LD      DE,$1AA6            ; "GAME OVER PLAYER< >"
16A5: 0E 14           LD      C,$14               ; 20 characters
16A7: CD 93 0A        CALL    PrintMessageDel     ; Print message
16AA: 25              DEC     H                   ; Back up ...
16AB: 25              DEC     H                   ; ... to player indicator
16AC: 06 1B           LD      B,$1B               ; "1"
16AE: 3A 67 20        LD      A,(playerDataMSB)   ; Player number
16B1: 0F              RRCA                        ; Is this player 1?
16B2: DA B7 16        JP      C,$16B7             ; Yes ... keep the digit
16B5: 06 1C           LD      B,$1C               ; Else ... set digit 2
16B7: 78              LD      A,B                 ; To A
16B8: CD FF 08        CALL    DrawChar            ; Print player number
16BB: CD B1 0A        CALL    OneSecDelay         ; Short delay
16BE: CD E7 18        CALL    $18E7               ; Get current player "alive" flag
16C1: 7E              LD      A,(HL)              ; Is player ...
16C2: A7              AND     A                   ; ... alive?
16C3: CA C9 16        JP      Z,$16C9             ; No ... skip to "GAME OVER" sequence
16C6: C3 ED 02        JP      $02ED               ; Switch players and game loop
*/
  hl = 0x2D18;
  de = 0x1AA6;
  c = 0xa;
  PrintMessageDel();
  TwoSecDelay();
  ClearPlayField();
  a = a ^ a;
  gameMode = a;
  io_write(io.SOUND2, a);
  EnableGameTasks();
  ^goto (0xB89 as func);
/*
16C9: 21 18 2D        LD      HL,$2D18            ; Screen coordinates
16CC: 11 A6 1A        LD      DE,$1AA6            ; "GAME OVER PLAYER< >"
16CF: 0E 0A           LD      C,$0A               ; Just the "GAME OVER" part
16D1: CD 93 0A        CALL    PrintMessageDel     ; Print message
16D4: CD B6 0A        CALL    TwoSecDelay         ; Long delay
16D7: CD D6 09        CALL    ClearPlayField      ; Clear center window
16DA: AF              XOR     A                   ; Now in ...
16DB: 32 EF 20        LD      (gameMode),A        ; ... demo mode
16DE: D3 05           OUT     (SOUND2),A          ; All sound off
16E0: CD D1 19        CALL    EnableGameTasks     ; Enable ISR game tasks
16E3: C3 89 0B        JP      $0B89               ; Print credit information and do splash
*/
  sp = 0x2400;
  interrupt = true;
  a = a ^ a;
  playerAlive = a;
  ^do {
    PlayerShotHit();
    b = 4;
    SoundBits3On();
    (0xA59 as func)();
  } while !zero;
  DisableGameTasks();
  hl = 0x2701;
  (0x19FA as func)();
  a = a ^ a;
  (0x1A8B as func)();
/*  
16E6: 31 00 24        LD      SP,$2400            ; Reset stack
16E9: FB              EI                          ; Enable interrupts
16EA: AF              XOR     A                   ; Flag ...
16EB: 32 15 20        LD      (playerAlive),A     ; ... player is shot
16EE: CD D8 14        CALL    PlayerShotHit       ; Player's shot collision detection
16F1: 06 04           LD      B,$04               ; Player has been hit ...
16F3: CD FA 18        CALL    SoundBits3On        ; ... sound
16F6: CD 59 0A        CALL    $0A59               ; Has flag been set?
16F9: C2 EE 16        JP      NZ,$16EE            ; No ... wait for the flag
16FC: CD D7 19        CALL    DsableGameTasks     ; Disable ISR game tasks
16FF: 21 01 27        LD      HL,$2701            ; Player's stash of ships
1702: CD FA 19        CALL    $19FA               ; Erase the stash of shps
1705: AF              XOR     A                   ; Print ...
1706: CD 8B 1A        CALL    $1A8B               ; ... a zero (number of ships)
*/
  b = 0xfb;
  ^goto (0x196B as func);
/*  
1709: 06 FB           LD      B,$FB               ; Turn off ...
170B: C3 6B 19        JP      $196B               ; ... player shot sound

  */
}
in rom @ 0x170E {
//; Use the player's MSB to determine how fast the aliens reload their
//; shots for another fire.  
  func AShotReloadRate() {
    (0x9CA as func)();
    hl++;
    a = *(hl as *u8);
    de = 0x1CB8;
    hl = 0x1AA1;
    c = 4;
    b = a;
    ^do {
      a = *(de as *u8);
      cmp(a,b);
//      ^goto (0x1727 as func) if !carry;
      ^break if !carry;
      hl++;
      de++;
      c--;
    } while !zero;
    a = *(hl as *u8);
  aShotReloadRate = a;      
/*
170E: CD CA 09        CALL    $09CA               ; Get score descriptor for active player
1711: 23              INC     HL                  ; MSB value
1712: 7E              LD      A,(HL)              ; Get the MSB value
1713: 11 B8 1C        LD      DE,$1CB8            ; Score MSB table
1716: 21 A1 1A        LD      HL,$1AA1            ; Corresponding fire reload rate table
1719: 0E 04           LD      C,$04               ; Only 4 entries (a 5th value of 7 is used after that)
171B: 47              LD      B,A                 ; Hold the score value
171C: 1A              LD      A,(DE)              ; Get lookup from table
171D: B8              CP      B                   ; Compare them
171E: D2 27 17        JP      NC,$1727            ; Equal or below ... use this table entry
1721: 23              INC     HL                  ; Next ...
1722: 13              INC     DE                  ; ... entry in table
1723: 0D              DEC     C                   ; Do all ...
1724: C2 1C 17        JP      NZ,$171C            ; ... 4 entries in the tables
1727: 7E              LD      A,(HL)              ; Load the shot reload value
1728: 32 CF 20        LD      (aShotReloadRate),A ; Save the value for use in shot routine
172B: C9              RET                         ; Done
*/
  }
}
in rom @ 0x172C {
//; Shot sound on or off depending on 2025
ShotSound:
  a = plyrShotStatus;
  cmp(a,0);
  ^if zero {
    b = 0xfd;
    ^goto SoundBits3Off;
  }
/*172C: 3A 25 20        LD      A,(plyrShotStatus)  ; Player shot flag
172F: FE 00           CP      $00                 ; Active shot?
1731: C2 39 17        JP      NZ,$1739            ; Yes ... go
1734: 06 FD           LD      B,$FD               ; Sound mask
1736: C3 DC 19        JP      SoundBits3Off       ; Mask off sound
*/
  b = 2;
  ^goto SoundBits3On;
  /*
1739: 06 02           LD      B,$02               ; Sound bit
173B: C3 FA 18        JP      SoundBits3On        ; OR on sound
  */
  nop();
  nop();
/*
173E: 00 00 ; ** Why?
*/
}
in rom @ 0x1740 {
/*
; This called from the ISR times down the fleet and sets the flag at 2095 if
; the fleet needs a change in sound handling (new delay, new sound)
*/
  TimeFleetSound:
  hl = 0x209B;
  --*(hl as *u8);
  const data_1744 : [u8;3] = [0xcc, 0x6d, 0x17]; // CALL Z, 176D
  a = playerOK;
  a = a & a;
  ^if !zero {
    hl = 0x2096;
    --*(hl as *u8);
    return if !zero;
    hl = 0x2098;
    a = *(hl as *u8);
    io_write(io.SOUND2,a);
    a = numAliens;
    a = a & a;
    ^if !zero {
      hl--;
      a = *(hl as *u8);
      hl--;
      *(hl as *u8) = a;
      hl--;
      *(hl as *u8) = 1;
      a = 4;
      fleetSndHold = a;
      return;
    }
  }
/*1740: 21 9B 20        LD      HL,$209B            ; Pointer to hold time for fleet
1743: 35              DEC     (HL)                ; Decrement hold time
1744: CC 6D 17        CALL    Z,$176D             ; If 0 turn fleet movement sound off
1747: 3A 68 20        LD      A,(playerOK)        ; Is player OK?
174A: A7              AND     A                   ; 1  means OK
174B: CA 6D 17        JP      Z,$176D             ; Player not OK ... fleet movement sound off and out
174E: 21 96 20        LD      HL,$2096            ; Current time on fleet sound
1751: 35              DEC     (HL)                ; Count down
1752: C0              RET     NZ                  ; Not time to change sound ... out
1753: 21 98 20        LD      HL,$2098            ; Current sound port 3 value
1756: 7E              LD      A,(HL)              ; Get value
1757: D3 05           OUT     (SOUND2),A          ; Set sounds
1759: 3A 82 20        LD      A,(numAliens)       ; Number of aliens on active screen
175C: A7              AND     A                   ; Is it zero?
175D: CA 6D 17        JP      Z,$176D             ; Yes ... turn off fleet movement sound and out
1760: 2B              DEC     HL                  ; (2097) Point to fleet timer reload
1761: 7E              LD      A,(HL)              ; Get fleet delay value
1762: 2B              DEC     HL                  ; (2096) Point to fleet timer
1763: 77              LD      (HL),A              ; Reload the timer
1764: 2B              DEC     HL                  ; Point to change-sound
1765: 36 01           LD      (HL),$01            ; (2095) time to change sound
1767: 3E 04           LD      A,$04               ; Set hold ...
1769: 32 9B 20        LD      (fleetSndHold),A    ; ... time for fleet sound
176C: C9              RET                         ; Done
*/
  a = soundPort5;
  a = a & 0x30;
  io_write(io.SOUND2, a);
  return;
/*

176D: 3A 98 20        LD      A,(soundPort5)      ; Current sound port 3 value
1770: E6 30           AND     $30                 ; Mask off fleet movement sounds
1772: D3 05           OUT     (SOUND2),A          ; Set sounds
1774: C9              RET                         ; Out

*/
}
  

  
in rom @ 0x1775 {
/*
; This game-loop routine handles two sound functions. The routine does:
; 1) Time out the extra-ship awarded sound and turn it off when done
; 2) Load the fleet sound delay based on number of remaining aliens
; 3) Make the changing fleet sound
;
; The 2095 flag is set by the ISR and cleared here. The ISR does the timing and sets 2095 when it
; is time to make a new fleet sound.
;
*/
  FleetDelayExShip:
  a = changeFleetSnd;
  a = a & a;
  ^if !zero { // jump to 17AA
    hl = 0x1A11;
    de = 0x1A21;
    a = numAliens;
    cmp(a,*(hl as *u8));
    ^if carry { // jump to 178E
      hl++;
      de++;
      ^goto (0x1785 as func);
    }
    a = *(de as *u8);
    fleetSndReload = a;
    hl = 0x2098;
    a = *(hl as *u8);
    a = a & 0x30;
    b = a;
    a = *(hl as *u8);
    a = a & 0xf;
    const data_179C : u8 = 0x7;
    cmp(a,0x10);
    ^if zero {
      a = 1;
    }
    a = a | b;
    *(hl as *u8) = a;
    a = a ^ a;
    changeFleetSnd = a;
   }
/*
1775: 3A 95 20        LD      A,(changeFleetSnd)  ; Time for new ...
1778: A7              AND     A                   ; ... fleet movement sound?
1779: CA AA 17        JP      Z,$17AA             ; No ... skip to extra-man timing
177C: 21 11 1A        LD      HL,$1A11            ; Number of aliens list coupled ...
177F: 11 21 1A        LD      DE,$1A21            ; ... with delay list
1782: 3A 82 20        LD      A,(numAliens)       ; Get the number of aliens on the screen
1785: BE              CP      (HL)                ; Compare it to the first list value
1786: D2 8E 17        JP      NC,$178E            ; Number of live aliens is higher than value ... use the delay
1789: 23              INC     HL                  ; Move to ...
178A: 13              INC     DE                  ; ... next list value
178B: C3 85 17        JP      $1785               ; Find the right delay
178E: 1A              LD      A,(DE)              ; Get the delay from the second list
178F: 32 97 20        LD      (fleetSndReload),A  ; Store the new alien sound delay
1792: 21 98 20        LD      HL,$2098            ; Get current state ...
1795: 7E              LD      A,(HL)              ; ... of sound port
1796: E6 30           AND     $30                 ; Mask off all fleet movement sounds
1798: 47              LD      B,A                 ; Hold the value
1799: 7E              LD      A,(HL)              ; Get current state
179A: E6 0F           AND     $0F                 ; This time ONLY the fleet movement sounds
179C: 07              RLCA                        ; Shift next to next sound
179D: FE 10           CP      $10                 ; Overflow?
179F: C2 A4 17        JP      NZ,$17A4            ; No ... keep it
17A2: 3E 01           LD      A,$01               ; Reset back to first sound
17A4: B0              OR      B                   ; Add fleet sounds to current sound value
17A5: 77              LD      (HL),A              ; Store new sound value
17A6: AF              XOR     A                   ; Restart ...
17A7: 32 95 20        LD      (changeFleetSnd),A  ; ... waiting on fleet time
*/
  hl = 0x2099;
  --*(hl as *u8);
  return if !zero;
  b = 0xef;
  ^goto SoundBits3Off;
/*
17AA: 21 99 20        LD      HL,$2099            ; Sound timer for award extra ship
17AD: 35              DEC     (HL)                ; Time expired?
17AE: C0              RET     NZ                  ; No ... leave sound playing
17AF: 06 EF           LD      B,$EF               ; Turn off bit set with #$10 (award extra ship)
17B1: C3 DC 19        JP      SoundBits3Off       ; Stop sound and out
  */
}

in rom @ 0x17B4 {
func SndOffExtPly() {
  b = 0xef;
  hl = 0x2098;
  a = *(hl as *u8);
  a = a & b;
  *(hl as *u8) = a;
  io_write(io.SOUND2,a);
  /*
17B4: 06 EF           LD      B,$EF               ; Mask off sound bit 4 (Extended play)
17B6: 21 98 20        LD      HL,$2098            ; Current sound content
17B9: 7E              LD      A,(HL)              ; Get current sound bits
17BA: A0              AND     B                   ; Turn off extended play
17BB: 77              LD      (HL),A              ; Remember settings
17BC: D3 05           OUT     (SOUND2),A          ; Turn off extended play
17BE: C9              RET                         ; Out
*/
}
  nop();
  /*
17BF: 00 ; ** Why?
  */
  
}
  
in rom @ 0x17C0 {
  //Read control inputs for active player

  ReadInputs:
  a = playerDataMSB;
  const data17C3 : u8 = 0xf;
  ^if carry {
    a=io_read(io.INP1);
    return;
  }
  a = io_read(io.INP2);
  return;
/*
17C0: 3A 67 20        LD      A,(playerDataMSB)   ; Get active player
17C3: 0F              RRCA                        ; Test player
17C4: D2 CA 17        JP      NC,$17CA            ; Player 2 ... read port 2
17C7: DB 01           IN      A,(INP1)            ; Player 1 ... read port 1
17C9: C9              RET                         ; Out
17CA: DB 02           IN      A,(INP2)            ; Get controls for player 2
17CC: C9              RET                         ; Out
*/  
  
}
  
in rom @ 0x17CD {
  CheckHandleTilt:
  a = io_read(io.INP2);
  a = a & 0x04;
  return if zero;
  a = tilt;
  a = a & a;
  return if !zero;
  sp = 0x2400;
  b = 4;
  ^do {
    ClearPlayField();
    b--;
  } while !zero;
  a = 1;
  tilt = a;
  DisableGameTasks();
  interrupt = true;
  de = 0x1CBC;
  hl = 0x3016;
  c = 4;
  PrintMessageDel();
  OneSecDelay();
  a = a ^ a;
  tilt = a;
  waitStartLoop = a;
  ^goto (0x16C9 as func);
/*
17CD: DB 02           IN      A,(INP2)            ; Read input port
17CF: E6 04           AND     $04                 ; Tilt?
17D1: C8              RET     Z                   ; No tilt ... return
17D2: 3A 9A 20        LD      A,(tilt)            ; Already in TILT handle?
17D5: A7              AND     A                   ; 1 = yes
17D6: C0              RET     NZ                  ; Yes ... ignore it now
17D7: 31 00 24        LD      SP,$2400            ; Reset stack
17DA: 06 04           LD      B,$04               ; Do this 4 times
17DC: CD D6 09        CALL    ClearPlayField      ; Clear center window
17DF: 05              DEC     B                   ; All done?
17E0: C2 DC 17        JP      NZ,$17DC            ; No ... do again
17E3: 3E 01           LD      A,$01               ; Flag ...
17E5: 32 9A 20        LD      (tilt),A            ; ... handling TILT
17E8: CD D7 19        CALL    DsableGameTasks     ; Disable game tasks
17EB: FB              EI                          ; Re-enable interrupts
17EC: 11 BC 1C        LD      DE,$1CBC            ; Message "TILT"
17EF: 21 16 30        LD      HL,$3016            ; Center of screen
17F2: 0E 04           LD      C,$04               ; Four letters
17F4: CD 93 0A        CALL    PrintMessageDel     ; Print "TILT"
17F7: CD B1 0A        CALL    OneSecDelay         ; Short delay
17FA: AF              XOR     A                   ; Zero
17FB: 32 9A 20        LD      (tilt),A            ; TILT handle over
17FE: 32 93 20        LD      (waitStartLoop),A   ; Back into splash screens
1801: C3 C9 16        JP      $16C9               ; Handle game over for player
*/
}

  
in rom @ 0x1804 {
  CtrlSaucerSound:
  hl = 0x2084;
  a = *(hl as *u8);
  a = a & a;
  ^goto (0x707 as func) if zero;
  hl++;
  a = *(hl as *u8);
  a = a & a;
  return if !zero;
  b = 1;
  ^goto SoundBits3On;
/*
1804: 21 84 20        LD      HL,$2084            ; Saucer on screen flag
1807: 7E              LD      A,(HL)              ; Is the saucer ...
1808: A7              AND     A                   ; ... on the screen?
1809: CA 07 07        JP      Z,$0707             ; No ... UFO sound off
180C: 23              INC     HL                  ; Saucer hit flag
180D: 7E              LD      A,(HL)              ; (2085) Get saucer hit flag
180E: A7              AND     A                   ; Is saucer in "hit" sequence?
180F: C0              RET     NZ                  ; Yes ... out
1810: 06 01           LD      B,$01               ; Retrigger saucer ...
1812: C3 FA 18        JP      SoundBits3On        ; ... sound (retrigger makes it warble?)
*/  
  }
in rom @ 0x1815 {
/*
; Draw "SCORE ADVANCE TABLE"
*/
  DrawAdvTable:
  hl = 0x2810;
  de = 0x1ca3;
  c = 0x15;
  PrintMessage();
  a = 0xa;
  temp206C = a;
  bc = 0x1DBE;
  ReadPriStruct();
  ^if !carry {
    (0x1844 as func)();
    ^goto (0x1828 as func);
  /*
1815: 21 10 28        LD      HL,$2810            ; 0x410 is 1040 rotCol=32, rotRow=16
1818: 11 A3 1C        LD      DE,$1CA3            ; "*SCORE ADVANCE TABLE*"
181B: 0E 15           LD      C,$15               ; 21 bytes in message
181D: CD F3 08        CALL    PrintMessage        ; Print message
1820: 3E 0A           LD      A,$0A               ; 10 bytes in every "=xx POINTS" string
1822: 32 6C 20        LD      (temp206C),A        ; Hold the count
1825: 01 BE 1D        LD      BC,$1DBE            ; Coordinate/sprite for drawing table
1828: CD 56 18        CALL    ReadPriStruct       ; Get HL=coordinate, DE=image
182B: DA 37 18        JP      C,$1837             ; Move on if done
182E: CD 44 18        CALL    $1844               ; Draw 16-byte sprite
1831: C3 28 18        JP      $1828               ; Do all in table
*/
    OneSecDelay();
  }
  bc = 0x1DCF;
  ^while true {
    ReadPriStruct();
    return if carry;
    (0x184C as func)();
  }
/*
1834: CD B1 0A        CALL    OneSecDelay         ; One second delay
1837: 01 CF 1D        LD      BC,$1DCF            ; Coordinate/message for drawing table
183A: CD 56 18        CALL    ReadPriStruct       ; Get HL=coordinate, DE=message
183D: D8              RET     C                   ; Out if done
183E: CD 4C 18        CALL    $184C               ; Print message
1841: C3 3A 18        JP      $183A               ; Do all in table
*/
  push(bc);
  b = 0x10;
  DrawSimpSprite();
  bc = pop();
  return;
/*
1844: C5              PUSH    BC                  ; Hold BC
1845: 06 10           LD      B,$10               ; 16 bytes
1847: CD 39 14        CALL    DrawSimpSprite      ; Draw simple
184A: C1              POP     BC                  ; Restore BC
184B: C9              RET                         ; Out
*/
  push(bc);
  a = temp206C;
  c = a;
  PrintMessageDel();
  bc = pop();
  return;
/*  
184C: C5              PUSH    BC                  ; Hold BC
184D: 3A 6C 20        LD      A,(temp206C)        ; Count of 10 ...
1850: 4F              LD      C,A                 ; ... to C
1851: CD 93 0A        CALL    PrintMessageDel     ; Print the message with delay between letters
1854: C1              POP     BC                  ; Restore BC
1855: C9              RET                         ; Out
*/
  }

in rom @ 0x1856 {
/*
; Read a 4-byte print-structure pointed to by BC
; HL=Screen coordiante, DE=pointer to message
; If the first byte is FF then return with Carry Set, Carry Cleared otherwise.
*/
  ReadPriStruct:
  a = *(bc as *u8);
  cmp(a,0xff);
  const data_1859 : u8 = 0x37; // SCF
  //    carry = false;
  return if zero;
  l = a;
  bc++;
  a = *(bc as *u8);
  h = a;
  bc++;
  a = *(bc as *u8);
  e = a;
  bc++;
  a = *(bc as *u8);
  d = a;
  bc++;
  a = a & a;
  return;
/*
1856: 0A              LD      A,(BC)              ; Get the screen LSB
1857: FE FF           CP      $FF                 ; Valid?
1859: 37              SCF                         ; If not Carry will be Set
185A: C8              RET     Z                   ; Return if 255
185B: 6F              LD      L,A                 ; Screen LSB to L
185C: 03              INC     BC                  ; Next
185D: 0A              LD      A,(BC)              ; Read screen MSB
185E: 67              LD      H,A                 ; Screen MSB to H
185F: 03              INC     BC                  ; Next
1860: 0A              LD      A,(BC)              ; Read message LSB
1861: 5F              LD      E,A                 ; Message LSB to E
1862: 03              INC     BC                  ; Next
1863: 0A              LD      A,(BC)              ; Read message MSB
1864: 57              LD      D,A                 ; Message MSB to D
1865: 03              INC     BC                  ; Next (for next print)
1866: A7              AND     A                   ; Clear Carry
1867: C9              RET                         ; Done
*/  
  
}
in rom @ 0x1868 {
/*
; Moves a sprite up or down in splash mode. Interrupt moves the sprite. When it reaches
; Y value in 20CA the flag at 20CB is raised. The image flips between two pictures every
; 4 movements.
*/
  SplashSprite:
  hl = 0x20C2;
  ++*(hl as *u8);
  hl++;
  c = *(hl as *u8);
  AddDelta();
  b = a;
  a = splashTargetY;
  cmp(a,b);
  ^if !zero {
    a = splashAnForm;
    a = a & 4;
    hl = splashImRest;
    ^if zero {
      de = 0x30;
      hl += de;
    }
    splashImage = hl;
    hl = 0x20C5;
    ReadDesc();
    swap(de,hl);
    ^goto DrawSprite;
/*
1868: 21 C2 20        LD      HL,$20C2            ; Descriptor
186B: 34              INC     (HL)                ; Change image
186C: 23              INC     HL                  ; Point to delta-x
186D: 4E              LD      C,(HL)              ; Get delta-x
186E: CD D9 01        CALL    AddDelta            ; Add delta-X and delta-Y to X and Y
1871: 47              LD      B,A                 ; Current y coordinate
1872: 3A CA 20        LD      A,(splashTargetY)   ; Has sprite reached ...
1875: B8              CP      B                   ; ... target coordinate?
1876: CA 98 18        JP      Z,$1898             ; Yes ... flag and out
1879: 3A C2 20        LD      A,(splashAnForm)    ; Image number
187C: E6 04           AND     $04                 ; Watching bit 3 for flip delay
187E: 2A CC 20        LD      HL,(splashImRestLSB); Image
1881: C2 88 18        JP      NZ,$1888            ; Did bit 3 go to 0? No ... keep current image
1884: 11 30 00        LD      DE,$0030            ; 16*3 ...
1887: 19              ADD     HL,DE               ; ...  use other image form
1888: 22 C7 20        LD      (splashImageLSB),HL ; Image to descriptor structure
188B: 21 C5 20        LD      HL,$20C5            ; X,Y,Image descriptor
188E: CD 3B 1A        CALL    ReadDesc            ; Read sprite descriptor
1891: EB              EX      DE,HL               ; Image to DE, position to HL
1892: C3 D3 15        JP      DrawSprite          ; Draw the sprite
*/
    nop();
    nop();
    nop();
/*
1895: 00 00 00                          
*/
  }
  a = 1;
  splashReached = a;
  return;
    /*
1898: 3E 01           LD      A,$01               ; Flag that sprite ...
189A: 32 CB 20        LD      (splashReached),A   ; ... reached location
189D: C9              RET                         ; Out
  */
  
}
in rom @ 0x18D4 {
// Initializiation comes here

  init:
  sp = 0x2400;
  b = 0;
  (0x1e6 as func)();
  DrawStatus();
  /*
18D4: 31 00 24        LD      SP,$2400            ; Set stack pointer just below screen
18D7: 06 00           LD      B,$00               ; Count 256 bytes
18D9: CD E6 01        CALL    $01E6               ; Copy ROM to RAM
18DC: CD 56 19        CALL    DrawStatus          ; Print scores and credits
*/
  a = 0x8;
  aShotReloadRate = a;
  ^goto (0xAEA as func);
  /*
18DF: 3E 08           LD      A,$08               ; Set alien ...
18E1: 32 CF 20        LD      (aShotReloadRate),A ; ... shot reload rate
18E4: C3 EA 0A        JP      $0AEA               ; Top of splash screen loop
*/

// Get player-alive flag for OTHER player
  a = playerDataMSB;
  hl = 0x20E7;
  const data18ed : u8 = 0xf; // RRCA
  return if !carry;
  hl++;
  return;
/*
18E7: 3A 67 20        LD      A,(playerDataMSB)   ; Player data MSB
18EA: 21 E7 20        LD      HL,$20E7            ; Alive flags (player 1 and 2)
18ED: 0F              RRCA                        ; Bit 1=1 for player 1
18EE: D0              RET     NC                  ; Player 2 ... we have it ... out
18EF: 23              INC     HL                  ; Player 1's flag
18F0: C9              RET                         ; Done
*/
}
  
in rom @ 0x18FA {
//; Add in bit for sound

  func SoundBits3On() {
    a = soundPort3;
    a = a | b;
    soundPort3 = a;
    io_write(io.SOUND1,a);
/*18FA: 3A 94 20        LD      A,(soundPort3)      ; Current value of sound port
18FD: B0              OR      B                   ; Add in new sounds
18FE: 32 94 20        LD      (soundPort3),A      ; New value of sound port
1901: D3 03           OUT     (SOUND1),A          ; Write new value to sound hardware
1903: C9              RET       
  */
  }
}
in rom @ 0x1904 {
  InitAliensP2:
  hl = 0x2200;
  ^goto (0x1c3 as func);
/*
1904: 21 00 22        LD      HL,$2200            ; Player 2 data area
1907: C3 C3 01        JP      $01C3               ; Initialize player 2 aliens
*/
}

in rom @ 0x190A {
  
  PlyrShotAndBump:
  PlayerShotHit();
  ^goto RackBump;
  /*
190A: CD D8 14        CALL    PlayerShotHit       ; Player's shot collision detection
190D: C3 97 15        JP      RackBump            ; Change alien deltaX and deltaY when rack bumps edges
*/
  }

in rom @ 0x1910 {
/*
; Get the current player's alive status
*/
  CurPlyAlive:
  hl = 0x20E7;
  a = playerDataMSB;
  const data_1916 : u8 = 0xf;
  return if carry;
  hl++;
  return;
  /*
1910: 21 E7 20        LD      HL,$20E7            ; Alive flags
1913: 3A 67 20        LD      A,(playerDataMSB)   ; Player 1 or 2
1916: 0F              RRCA                        ; Will be 1 if player 1
1917: D8              RET     C                   ; Return if player 1
1918: 23              INC     HL                  ; Bump to player 2
1919: C9              RET                         ; Return
  */
  
}
  
in rom @ 0x191A {
// Print score header " SCORE<1> HI-SCORE SCORE<2> "

  DrawScoreHead:
  c = 0x1C;
  hl = 0x241E;
  de = 0x1AE4;
  ^goto PrintMessage;
/*191A: 0E 1C           LD      C,$1C               ; 28 bytes in message
191C: 21 1E 24        LD      HL,$241E            ; Screen coordinates
191F: 11 E4 1A        LD      DE,$1AE4            ; Score header message
1922: C3 F3 08        JP      PrintMessage        ; Print score header
*/
  hl = 0x20F8;
  ^goto DrawScore;
/*
1925: 21 F8 20        LD      HL,$20F8            ; Player 1 score descriptor
1928: C3 31 19        JP      DrawScore           ; Print score
*/
  hl = 0x20FC;
//  const data @ 0x192E : [u8;3] = [0xC3, 0x31, 0x19];
  ^goto DrawScore;
/*
192B: 21 FC 20        LD      HL,$20FC            ; Player 2 score descriptor
192E: C3 31 19        JP      DrawScore           ; Print score
*/

// Print score.
// HL = descriptor

}
  
  in rom @ 0x1931 {
  DrawScore:
  e = *(hl as *u8);
  hl++;
  d = *(hl as *u8);
  hl++;
  a = *(hl as *u8);
  hl++;
  h = *(hl as *u8);
  l = a;
  ^goto Print4Digits;
/*
1931: 5E              LD      E,(HL)              ; Get score LSB
1932: 23              INC     HL                  ; Next
1933: 56              LD      D,(HL)              ; Get score MSB
1934: 23              INC     HL                  ; Next
1935: 7E              LD      A,(HL)              ; Get coordinate LSB
1936: 23              INC     HL                  ; Next
1937: 66              LD      H,(HL)              ; Get coordiante MSB
1938: 6F              LD      L,A                 ; Set LSB
1939: C3 AD 09        JP      Print4Digits        ; Print 4 digits in DE
*/
}

in rom @ 0x193C {
// ; Print message "CREDIT "
  c = 7;
  hl = 0x3501;
  de = 0x1fa9;
  ^goto PrintMessage;
  /*
193C: 0E 07           LD      C,$07               ; 7 bytes in message
193E: 21 01 35        LD      HL,$3501            ; Screen coordinates
1941: 11 A9 1F        LD      DE,$1FA9            ; Message = "CREDIT "
1944: C3 F3 08        JP      PrintMessage        ; Print message
 */
}
  
  
in rom @ 0x1947 {
  func DrawNumCredits{

    a = (numCoins);
    hl = 0x3C01;
    ^goto DrawHexByte;
    //  goto DrawHexByte;
  }
}
//; Display number of credits on screen
//1947: 3A EB 20        LD      A,(numCoins)        ; Number of credits
//194A: 21 01 3C        LD      HL,$3C01            ; Screen coordinates
//194D: C3 B2 09        JP      DrawHexByte         ; Character to screen

in rom @ 0x1950 {
  PrintHiScore:
  hl = 0x20F4;
  ^goto DrawScore;
/*
1950: 21 F4 20        LD      HL,$20F4            ; Hi Score descriptor
1953: C3 31 19        JP      DrawScore           ; Print Hi-Score
*/
}
in rom @ 0x1956 {
// Print scores (with header) and credits (with label)
  func DrawStatus() {
    ClearScreen();
    DrawScoreHead();
    (0x1925 as func)();
    (0x192B as func)();
    PrintHiScore();
    (0x193C as func)();
    ^goto DrawNumCredits;
/*
   1956: CD 5C 1A        CALL    ClearScreen         ; Clear the screen
1959: CD 1A 19        CALL    DrawScoreHead       ; Print score header
195C: CD 25 19        CALL    $1925               ; Print player 1 score
195F: CD 2B 19        CALL    $192B               ; Print player 2 score
1962: CD 50 19        CALL    PrintHiScore        ; Print hi score
1965: CD 3C 19        CALL    $193C               ; Print credit lable
1968: C3 47 19        JP      DrawNumCredits      ; Number of credits
*/
    
    SoundBits3Off();
    ^goto (0x1671 as func);
/*
196B: CD DC 19        CALL    SoundBits3Off       ; From 170B with B=FB. Turn off player shot sound
196E: C3 71 16        JP      $1671               ; Update high-score if player's score is greater
*/
    a = 1;
    invaded = a;
    ^goto (0x16e6 as func);
/*
1971: 3E 01           LD      A,$01               ; Set flag that ...
1973: 32 6D 20        LD      (invaded),A         ; ... aliens reached bottom of screen
1976: C3 E6 16        JP      $16E6               ; End of round
*/
    DisableGameTasks();
    DrawNumCredits();
    ^goto (0x193C as func);  
/*
1979: CD D7 19        CALL    DsableGameTasks     ; Disable ISR game tasks
197C: CD 47 19        CALL    DrawNumCredits      ; Display number of credits on screen
197F: C3 3C 19        JP      $193C               ; Print message "CREDIT"
*/
    isrSplashTask = a;
    return;
/*
1982: 32 C1 20        LD      (isrSplashTask),A   ; Set ISR splash task
1985: C9              RET                         ; Done
*/
  }
}
  
in rom @ 0x199A {
/*
; There is a hidden message "TAITO COP" (with no "R") in the game. It can only be
; displayed in the demonstration game during the splash screens. You must enter
; 2 seqences of buttons. Timing is not critical. As long as you eventually get all
; the buttons up/down in the correct pattern then the game will register the
; sequence.
;
; 1st: 2start(down) 1start(up)   1fire(down) 1left(down) 1right(down)
; 2nd: 2start(up)   1start(down) 1fire(down) 1left(down) 1right(up)
;
; Unfortunately MAME does not deliver the simultaneous button presses correctly. You can see the message in
; MAME by changing 19A6 to 02 and 19B1 to 02. Then the 2start(down) is the only sequence.
*/
  CheckHiddenMes:
  a = hidMessSeq;
/*
199A: 3A 1E 20        LD      A,(hidMessSeq)      ; Has the 1st "hidden-message" sequence ...
199D: A7              AND     A                   ; ... been registered?
199E: C2 AC 19        JP      NZ,$19AC            ; Yes ... go look for the 2nd sequence
19A1: DB 01           IN      A,(INP1)            ; Get player inputs
19A3: E6 76           AND     $76                 ; 0111_0110 Keep 2Pstart, 1Pstart, 1Pshot, 1Pleft, 1Pright
19A5: D6 72           SUB     $72                 ; 0111_0010 1st sequence: 2Pstart, 1Pshot, 1Pleft, 1Pright
19A7: C0              RET     NZ                  ; Not first sequence ... out
19A8: 3C              INC     A                   ; Flag that 1st sequence ...
19A9: 32 1E 20        LD      (hidMessSeq),A      ; ... has been entered
19AC: DB 01           IN      A,(INP1)            ; Check inputs for 2nd sequence
19AE: E6 76           AND     $76                 ; 0111_0110 Keep 2Pstart, 1Pstart, 1Pshot, 1Pleft, 1Pright
19B0: FE 34           CP      $34                 ; 0011_0100 2nd sequence: 1Pstart, 1Pshot, 1Pleft
19B2: C0              RET     NZ                  ; If not second sequence ignore
19B3: 21 1B 2E        LD      HL,$2E1B            ; Screen coordinates
19B6: 11 F7 0B        LD      DE,$0BF7            ; Message = "TAITO COP" (no R)
19B9: 0E 09           LD      C,$09               ; Message length
19BB: C3 F3 08        JP      PrintMessage        ; Print message and out
  */
}

in rom @ 0x19D1 {
// Enable ISR game tasks

  func EnableGameTasks() {

    a = 1;
    suspendPlay = a;
/*
19D1: 3E 01           LD      A,$01               ; Set ISR ...
19D3: 32 E9 20        LD      (suspendPlay),A     ; ... game tasks enabled
19D6: C9              RET                         ; Done
*/  
  }

}
  
in rom @ 0x19D7 {
// Disable ISR game tasks
// Clear 20E9 flag
  DisableGameTasks:
  a = a ^ a;
  ^goto 0x19D3 as func;
  nop();
/*
19D7: AF              XOR     A                   ; Clear ISR game tasks flag
19D8: C3 D3 19        JP      $19D3               ; Save a byte (the RET)
19DB: 00                                          ; ** Here is the byte saved. I wonder if this was an optimizer pass.
*/

}
  
in rom @ 0x19DC {
// Turn off bit in sound port

  func SoundBits3Off() {
    a = soundPort3;
    a = a & b;
    soundPort3 = a;
    io_write(io.SOUND1,a);
/*
19DC: 3A 94 20        LD      A,(soundPort3)      ; Current sound effects value
19DF: A0              AND     B                   ; Mask bits off
19E0: 32 94 20        LD      (soundPort3),A      ; Store new hold value
19E3: D3 03           OUT     (SOUND1),A          ; Change sounds
19E5: C9              RET                         ; Done
*/
  }
}

in rom @ 0x19E6 {
// Show ships remaining in hold for the player

  func DrawNumShips() {
    hl = 0x2701;
    /*
19E6: 21 01 27        LD      HL,$2701            ; Screen coordinates
*/
    if !zero { //^goto 0x19FA if zero;
      /*
19E9: CA FA 19        JP      Z,$19FA             ; None in reserve ... skip display
*/
      // Draw line of ships

      ^do {
        de = 0x1c60;
        b = 0x10;
        c = a;
        DrawSimpSprite();
        a = c;
        a--;
      } while !zero;
      /*
19EC: 11 60 1C        LD      DE,$1C60            ; Player sprite
19EF: 06 10           LD      B,$10               ; 16 rows
19F1: 4F              LD      C,A                 ; Hold count
19F2: CD 39 14        CALL    DrawSimpSprite      ; Display 1byte sprite to screen
19F5: 79              LD      A,C                 ; Restore remaining
19F6: 3D              DEC     A                   ; All done?
19F7: C2 EC 19        JP      NZ,$19EC            ; No ... keep going
*/
    }
    // Clear remainder of line
    ^do {
      b = 0x10;
      ClearSmallSprite();
      a = h;
      cmp(a,0x35);
    } while !zero;
/*
19FA: 06 10           LD      B,$10               ; 16 rows
19FC: CD CB 14        CALL    ClearSmallSprite    ; Clear 1byte sprite at HL
19FF: 7C              LD      A,H                 ; Get Y coordinate
1A00: FE 35           CP      $35                 ; At edge?
1A02: C2 FA 19        JP      NZ,$19FA            ; No ... do all
1A05: C9              RET                         ; Out
*/  
  }

}

in rom @ 0x1A06 {
/*
;
; The ISRs set the upper bit of 2072 based on where the beam is. This is compared to the
; upper bit of an object's Y coordinate to decide whic ISR should handle it. When the
; beam passes the halfway point (or near it ... at scanline 96), the upper bit is cleared.
; When the beam reaches the end of the screen the upper bit is set.
;
; The task then runs in the ISR if the Y coordiante bit matches the 2072 flag. Objects that
; are at the top of the screen (upper bit of Y clear) run in the mid-screen ISR when
; the beam has moved to the bottom of the screen. Objects that are at the bottom of the screen
; (upper bit of Y set) run in the end-screen ISR when the beam is moving back to the top.
;
; The pointer to the object's Y coordinate is passed in DE. CF is set if the upper bits are
; the same (the calling ISR should execute the task).
;
*/
  func CompYToBeam() {
    hl = 0x2072;
    b = *(hl as *u8);
    a = *(de as *u8);
    a = a & 0x80;
    a = a ^ b;
    return if !zero;
    carry = true;
/*
1A06: 21 72 20        LD      HL,$2072            ; Get the ...
1A09: 46              LD      B,(HL)              ; ... beam position status
1A0A: 1A              LD      A,(DE)              ; Get the task structure flag
1A0B: E6 80           AND     $80                 ; Only upper bits count
1A0D: A8              XOR     B                   ; XOR them together
1A0E: C0              RET     NZ                  ; Not the same (CF cleared)
1A0F: 37              SCF                         ; Set the CF if the same
1A10: C9              RET                         ; Done
  */
  }
  
}
in rom @ 0x1A32 {
//    BlockCopy:
/*
; Copy from [DE] to [HL] (b bytes)
*/
  func BlockCopy() {
    ^do {
      a = *(de as *u8);
      *(hl as *u8) = a;
      hl++;
      de++;
      b--;
    } while !zero;
  }
/*1A32: 1A              LD      A,(DE)              ; Copy from [DE] to ...
1A33: 77              LD      (HL),A              ; ... [HL]
1A34: 23              INC     HL                  ; Next destination
1A35: 13              INC     DE                  ; Next source
1A36: 05              DEC     B                   ; Count in B
1A37: C2 32 1A        JP      NZ,BlockCopy        ; Do all
1A3A: C9              RET                         ; Done
*/
}
  
  
in rom @ 0x1A3B {
// Load 5 bytes sprite descriptor from [HL]

  func ReadDesc() {
    e = *(hl as *u8);
/*
1A3B: 5E              LD      E,(HL)              ; Descriptor ...
1A3C: 23              INC     HL                  ; ... sprite ...
1A3D: 56              LD      D,(HL)              ; ...
1A3E: 23              INC     HL                  ; ... picture
1A3F: 7E              LD      A,(HL)              ; Descriptor ...
1A40: 23              INC     HL                  ; ... screen ...
1A41: 4E              LD      C,(HL)              ; ...
1A42: 23              INC     HL                  ; ... location
1A43: 46              LD      B,(HL)              ; Number of bytes in sprite
1A44: 61              LD      H,C                 ; From A,C to ...
1A45: 6F              LD      L,A                 ; ... H,L
1A46: C9              RET                         ; Done
*/
  }
}
  
in rom @ 0x1A47 {
/*
; The screen is organized as one-bit-per-pixel.
; In: HL contains pixel number (bbbbbbbbbbbbbppp)
; Convert from pixel number to screen coordinates (without shift)
; Shift HL right 3 bits (clearing the top 2 bits)
; and set the third bit from the left.
*/
  func ConvToScr() {
    /*
1A47: C5              PUSH    BC                  ; Hold B (will mangle)
1A48: 06 03           LD      B,$03               ; 3 shifts (divide by 8)
1A4A: 7C              LD      A,H                 ; H to A
1A4B: 1F              RRA                         ; Shift right (into carry, from doesn't matter)
1A4C: 67              LD      H,A                 ; Back to H
1A4D: 7D              LD      A,L                 ; L to A
1A4E: 1F              RRA                         ; Shift right (from/to carry)
1A4F: 6F              LD      L,A                 ; Back to L
1A50: 05              DEC     B                   ; Do all ...
1A51: C2 4A 1A        JP      NZ,$1A4A            ; ... 3 shifts
1A54: 7C              LD      A,H                 ; H to A
1A55: E6 3F           AND     $3F                 ; Mask off all but screen (less than or equal 3F)
1A57: F6 20           OR      $20                 ; Offset into RAM
1A59: 67              LD      H,A                 ; Back to H
1A5A: C1              POP     BC                  ; Restore B
1A5B: C9              RET                         ; Done
  */
  }
  
}
in rom @ 0x1A5C {
// Clear the screen
// Thanks to Mark Tankard for pointing out what this really does
  func ClearScreen() {
    hl = 0x2400;
    ^do {
      *(hl as *u8) = 0;
      hl++;
      a = h;
      cmp(a,0x40);
    } while !zero;
/*
1A5C: 21 00 24        LD      HL,$2400            ; Screen coordinate
1A5F: 36 00           LD      (HL),$00            ; Clear it
1A61: 23              INC     HL                  ; Next byte
1A62: 7C              LD      A,H                 ; Have we done ...
1A63: FE 40           CP      $40                 ; ... all the screen?
1A65: C2 5F 1A        JP      NZ,$1A5F            ; No ... keep going
1A68: C9              RET                         ; Out
*/ 
  }
}
  
in rom @ 0x1A69 {
/*
; Logically OR the player's shields back onto the playfield
; DE = sprite
; HL = screen
; C = bytes per row
; B = number of rows
*/
  func RestoreShields() {
    ^do {
      push(bc);
      push(hl);
      ^do {
        a = *(de as *u8);
        a = a | *(hl as *u8);
        *(hl as *u8) = a;
        de++;
        hl++;
        c--;
      } while !zero;

      hl = pop();
      bc = 0x20;
      hl +=bc;
      bc = pop();
      b--;
    } while !zero;
/*
1A69: C5              PUSH    BC                  ; Preserve BC
1A6A: E5              PUSH    HL                  ; Hold for a bit
1A6B: 1A              LD      A,(DE)              ; From sprite
1A6C: B6              OR      (HL)                ; OR with screen
1A6D: 77              LD      (HL),A              ; Back to screen
1A6E: 13              INC     DE                  ; Next sprite
1A6F: 23              INC     HL                  ; Next on screen
1A70: 0D              DEC     C                   ; Row done?
1A71: C2 6B 1A        JP      NZ,$1A6B            ; No ... do entire row
1A74: E1              POP     HL                  ; Original start
1A75: 01 20 00        LD      BC,$0020            ; Bump HL by ...
1A78: 09              ADD     HL,BC               ; ... one screen row
1A79: C1              POP     BC                  ; Restore
1A7A: 05              DEC     B                   ; Row counter
1A7B: C2 69 1A        JP      NZ,RestoreShields   ; Do all rows
1A7E: C9              RET                         
*/
   }
}
  

in rom @ 0x1A7F {
// Remove a ship from the players stash and update the
// hold indicators on the screen.

  RemoveShip:
  (0x92E as func)();
  a = a & a;
  return if zero;
  push(af);
  a--;
  *(hl as *u8) = a;
  DrawNumShips();
  af = pop();
  hl = 0x2501;
  a = a & 0x0f;
  ^goto (0x9C5 as func);
/*
1A7F: CD 2E 09        CALL    $092E               ; Get last byte from player data
1A82: A7              AND     A                   ; Is it 0?
1A83: C8              RET     Z                   ; Skip
1A84: F5              PUSH    AF                  ; Preserve number remaining
1A85: 3D              DEC     A                   ; Remove a ship from the stash
1A86: 77              LD      (HL),A              ; New number of ships
1A87: CD E6 19        CALL    DrawNumShips        ; Draw the line of ships
1A8A: F1              POP     AF                  ; Restore number
1A8B: 21 01 25        LD      HL,$2501            ; Screen coordinates
1A8E: E6 0F           AND     $0F                 ; Make sure it is a digit
1A90: C3 C5 09        JP      $09C5               ; Print number remaining  
  */
}
  
  
in rom @ 0x1B00 {
/*
;-------------------------- RAM initialization -----------------------------
; Coppied to RAM (2000) C0 bytes as initialization.
; See the description of RAM at the top of this file for the details on this data.
*/
const data1b00 : [u8] = [
  0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x78, 0x38, 0x78, 0x38, 0x00, 0xF8, 0x00, 
  0x00, 0x80, 0x00, 0x8E, 0x02, 0xFF, 0x05, 0x0C, 0x60, 0x1C, 0x20, 0x30, 0x10, 0x01, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xBB, 0x03, 0x00, 0x10, 0x90, 0x1C, 0x28, 0x30, 0x01, 0x04, 0x00, 0xFF, 0xFF, 
  0x00, 0x00, 0x02, 0x76, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xEE, 0x1C, 0x00, 0x00, 0x03, 
  0x00, 0x00, 0x00, 0xB6, 0x04, 0x00, 0x00, 0x01, 0x00, 0x1D, 0x04, 0xE2, 0x1C, 0x00, 0x00, 0x03, 
  0x00, 0x00, 0x00, 0x82, 0x06, 0x00, 0x00, 0x01, 0x06, 0x1D, 0x04, 0xD0, 0x1C, 0x00, 0x00, 0x03, 
  0xFF, 0x00, 0xC0, 0x1C, 0x00, 0x00, 0x10, 0x21, 0x01, 0x00, 0x30, 0x00, 0x12, 0x00, 0x00, 0x00
];
  /*
1B00: 01 00 00 10 00 00 00 00 02 78 38 78 38 00 F8 00
1B10: 00 80 00 8E 02 FF 05 0C 60 1C 20 30 10 01 00 00   
1B20: 00 00 00 BB 03 00 10 90 1C 28 30 01 04 00 FF FF   
1B30: 00 00 02 76 04 00 00 00 00 00 04 EE 1C 00 00 03    
1B40: 00 00 00 B6 04 00 00 01 00 1D 04 E2 1C 00 00 03 
1B50: 00 00 00 82 06 00 00 01 06 1D 04 D0 1C 00 00 03
1B60: FF 00 C0 1C 00 00 10 21 01 00 30 00 12 00 00 00         
  
  */
}
  
in rom @ 0x1ED0 {
  const data1ed0 : [u8] = [
    0x00, 0x3E, 0x45, 0x49, 0x51, 0x3E, 0x00, 0x00
    ];
  /*
  1ED0: 00 3E 45 49 51 3E 00 00  
  */
  }
  
in rom @ 0x1F40 {

  const data1f40 : [u8] = [
    0x00, 0x22, 0x14, 0x7F, 0x14, 0x22, 0x00, 0x00,
    0x00, 0x03, 0x04, 0x78, 0x04, 0x03, 0x00, 0x00
    ];
  /*
1F40: 00 22 14 7F 14 22 00 00  ; ........ ........
1F48: 00 03 04 78 04 03 00 00  ; .*...*.. **......
                               ; ..*.*... ..*.....
                               ; *******. ...****.
                               ; ..*.*... ..*.....
                               ; .*...*.. **......
                               ; ........ ........
                               ; ........ ........
 */
}
  
in rom @ 0x1F9C {
MessageCredit:
  const data1fa9 : [u8] = [
    0x02, 0x11, 0x04, 0x03, 0x08, 0x13, 0x26
    ];
/*
1FA9: 02 11 04 03 08 13 26       ; "CREDIT " (with space on the end)
*/    
    
}